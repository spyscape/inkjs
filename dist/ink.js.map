{"version":3,"file":"ink.js","sources":["../src/Path.ts","../src/Debug.ts","../src/TypeAssertion.ts","../src/NullException.ts","../src/Object.ts","../src/StringBuilder.ts","../src/InkList.ts","../src/StoryException.ts","../src/TryGetResult.ts","../src/Value.ts","../src/Container.ts","../src/SearchResult.ts","../src/ControlCommand.ts","../src/PushPop.ts","../src/Glue.ts","../src/Pointer.ts","../src/Divert.ts","../src/ChoicePoint.ts","../src/VariableReference.ts","../src/VariableAssignment.ts","../src/Void.ts","../src/NativeFunctionCall.ts","../src/Tag.ts","../src/Choice.ts","../src/ListDefinition.ts","../src/ListDefinitionsOrigin.ts","../src/JsonSerialisation.ts","../src/CallStack.ts","../src/Story.ts","../src/VariablesState.ts","../src/PRNG.ts","../src/StoryState.ts","../src/StopWatch.ts"],"sourcesContent":["export class Path{\n\tpublic static parentId = '^';\n\n\tpublic _isRelative: boolean;\n\tpublic _components: Path.Component[];\n\tpublic _componentsString: string | null;\n\n\tconstructor();\n\tconstructor(componentsString: string);\n\tconstructor(head: Path.Component, tail: Path);\n\tconstructor(head: Path.Component[], relative?: boolean);\n\tconstructor(){\n\t\tthis._components = [];\n\t\tthis._componentsString = null;\n\t\tthis._isRelative = false;\n\n\t\tif (typeof arguments[0] == 'string'){\n\t\t\tlet componentsString = arguments[0] as string;\n\t\t\tthis.componentsString = componentsString;\n\t\t}\n\t\telse if (arguments[0] instanceof Path.Component && arguments[1] instanceof Path){\n\t\t\tlet head = arguments[0] as Path.Component;\n\t\t\tlet tail = arguments[1] as Path;\n\t\t\tthis._components.push(head);\n\t\t\tthis._components = this._components.concat(tail._components);\n\t\t}\n\t\telse if (arguments[0] instanceof Array){\n\t\t\tlet head = arguments[0] as Path.Component[];\n\t\t\tlet relative = !!arguments[1] as boolean;\n\t\t\tthis._components = this._components.concat(head);\n\t\t\tthis._isRelative = relative;\n\t\t}\n\t}\n\tget isRelative(){\n\t\treturn this._isRelative;\n\t}\n\tget componentCount(): number{\n\t\treturn this._components.length;\n\t}\n\tget head(): Path.Component | null{\n\t\tif (this._components.length > 0) {\n\t\t\treturn this._components[0];\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\tget tail(): Path{\n\t\tif (this._components.length >= 2) {\n\t\t\t// careful, the original code uses length-1 here. This is because the second argument of\n\t\t\t// List.GetRange is a number of elements to extract, wherease Array.slice uses an index\n\t\t\tlet tailComps = this._components.slice(1, this._components.length);\n\t\t\treturn new Path(tailComps);\n\t\t}\n\t\telse {\n\t\t\treturn Path.self;\n\t\t}\n\t}\n\tget length(): number{\n\t\treturn this._components.length;\n\t}\n\tget lastComponent(): Path.Component | null{\n\t\tlet lastComponentIdx = this._components.length - 1;\n\t\tif (lastComponentIdx >= 0) {\n\t\t\treturn this._components[lastComponentIdx];\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\tget containsNamedComponent(): boolean{\n\t\tfor (let i = 0, l = this._components.length; i < l; i++){\n\t\t\tif (!this._components[i].isIndex){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tstatic get self(): Path{\n\t\tlet path = new Path();\n\t\tpath._isRelative = true;\n\t\treturn path;\n\t}\n\n\tpublic GetComponent(index: number): Path.Component{\n\t\treturn this._components[index];\n\t}\n\tpublic PathByAppendingPath(pathToAppend: Path): Path{\n\t\tlet p = new Path();\n\n\t\tlet upwardMoves = 0;\n\t\tfor (let i = 0; i < pathToAppend._components.length; ++i) {\n\t\t\tif (pathToAppend._components[i].isParent) {\n\t\t\t\tupwardMoves++;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor (let i = 0; i < this._components.length - upwardMoves; ++i) {\n\t\t\tp._components.push(this._components[i]);\n\t\t}\n\n\t\tfor (let i = upwardMoves; i < pathToAppend._components.length; ++i) {\n\t\t\tp._components.push(pathToAppend._components[i]);\n\t\t}\n\n\t\treturn p;\n\t}\n\tget componentsString(): string{\n\t\tif (this._componentsString == null) {\n\t\t\tthis._componentsString = this._components.join('.');\n\t\t\tif (this.isRelative) this._componentsString = '.' + this._componentsString;\n\t\t}\n\n\t\treturn this._componentsString;\n\t}\n\tset componentsString(value: string){\n\t\tthis._components.length = 0;\n\n\t\tthis._componentsString = value;\n\n\t\tif (this._componentsString == null || this._componentsString == '') return;\n\n\t\tif (this._componentsString[0] == '.') {\n\t\t\tthis._isRelative = true;\n\t\t\tthis._componentsString = this._componentsString.substring(1);\n\t\t}\n\n\t\tlet componentStrings = this._componentsString.split('.');\n\t\tfor (let str of componentStrings) {\n\t\t\t// we need to distinguish between named components that start with a number, eg \"42somewhere\", and indexed components\n\t\t\t// the normal parseInt won't do for the detection because it's too relaxed.\n\t\t\t// see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt\n\t\t\tif (/^(\\-|\\+)?([0-9]+|Infinity)$/.test(str)){\n\t\t\t\tthis._components.push(new Path.Component(parseInt(str)));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tthis._components.push(new Path.Component(str));\n\t\t\t}\n\t\t}\n\t}\n\tpublic toString(): string{\n\t\treturn this.componentsString;\n\t}\n\tpublic Equals(otherPath: Path | null): boolean{\n\t\tif (otherPath == null)\n\t\t\treturn false;\n\n\t\tif (otherPath._components.length != this._components.length)\n\t\t\treturn false;\n\n\t\tif (otherPath.isRelative != this.isRelative)\n\t\t\treturn false;\n\n\t\t// the original code uses SequenceEqual here, so we need to iterate over the components manually.\n\t\tfor (let i = 0, l = otherPath._components.length; i < l; i++){\n\t\t\t// it's not quite clear whether this test should use Equals or a simple == operator,\n\t\t\t// see https://github.com/y-lohse/inkjs/issues/22\n\t\t\tif (!otherPath._components[i].Equals(this._components[i])) return false;\n\t\t}\n\n\t\treturn true;\n\t}\n\tpublic PathByAppendingComponent(c: Path.Component): Path{\n\t\tlet p = new Path();\n\t\tp._components.push.apply(p._components, this._components);\n\t\tp._components.push(c);\n\t\treturn p;\n\t}\n}\n\nexport namespace Path {\n\texport class Component{\n\t\tpublic readonly index: number;\n\t\tpublic readonly name: string | null;\n\n\t\tconstructor(indexOrName: string | number){\n\t\t\tthis.index = -1;\n\t\t\tthis.name = null;\n\t\t\tif (typeof indexOrName == 'string'){\n\t\t\t\tthis.name = indexOrName;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tthis.index = indexOrName;\n\t\t\t}\n\t\t}\n\t\tget isIndex(): boolean{\n\t\t\treturn this.index >= 0;\n\t\t}\n\t\tget isParent(): boolean{\n\t\t\treturn this.name == Path.parentId;\n\t\t}\n\n\t\tpublic static ToParent(): Component{\n\t\t\treturn new Component(Path.parentId);\n\t\t}\n\t\tpublic toString(): string | null{\n\t\t\tif (this.isIndex) {\n\t\t\t\treturn this.index.toString();\n\t\t\t} else {\n\t\t\t\treturn this.name;\n\t\t\t}\n\t\t}\n\t\tpublic Equals(otherComp: Component): boolean{\n\t\t\tif (otherComp != null && otherComp.isIndex == this.isIndex) {\n\t\t\t\tif (this.isIndex) {\n\t\t\t\t\treturn this.index == otherComp.index;\n\t\t\t\t} else {\n\t\t\t\t\treturn this.name == otherComp.name;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\t}\n}\n","export namespace Debug {\n\t// tslint:disable no-string-throw\n\texport function AssertType<T>(variable: any, type: new () => T, message: string): void | never {\n\t\tAssert(variable instanceof type, message);\n\t}\n\n\texport function Assert(condition: boolean, message?: string): void | never {\n\t\tif (!condition) {\n\t\t\t// tslint:disable:no-console\n\t\t\tif (typeof message !== 'undefined') {\n\t\t\t\tconsole.warn(message);\n\t\t\t}\n\n\t\t\tif (console.trace) {\n\t\t\t\tconsole.trace();\n\t\t\t}\n\n\t\t\tthrow '';\n\t\t}\n\t}\n}\n","import {INamedContent} from './INamedContent';\n\n// tslint:disable ban-types\n\nexport function asOrNull<T>(obj: any, type: (new (...arg: any[]) => T) | Function & { prototype: T }): T | null{\n\tif (obj instanceof type) {\n\t\treturn unsafeTypeAssertion(obj, type);\n\t} else {\n\t\treturn null;\n\t}\n}\n\nexport function asOrThrows<T>(obj: any, type: (new (...arg: any[]) => T) | Function & { prototype: T }): T | never{\n\tif (obj instanceof type) {\n\t\treturn unsafeTypeAssertion(obj, type);\n\t} else {\n\t\tthrow new Error(`${obj} is not of type ${type}`);\n\t}\n}\n\nexport function asNumberOrThrows(obj: any){\n\tif (typeof obj === 'number') {\n\t\treturn obj as number;\n\t} else {\n\t\tthrow new Error(`${obj} is not a number`);\n\t}\n}\n\n// So here, in the reference implementation, contentObj is casted to an INamedContent\n// but here we use js-style duck typing: if it implements the same props as the interface,\n// we treat it as valid.\nexport function asINamedContentOrNull(obj: any): INamedContent | null {\n\tif (obj.hasValidName && obj.name) {\n\t\treturn obj as INamedContent;\n\t}\n\n\treturn null;\n}\n\nexport function nullIfUndefined<T>(obj: T | undefined): T | null {\n\tif (typeof obj === 'undefined') {\n\t\treturn null;\n\t}\n\n\treturn obj;\n}\n\nfunction unsafeTypeAssertion<T>(obj: any, type: (new () => T) | Function & { prototype: T }){\n\treturn obj as T;\n}\n","/**\n * In the original C# code, a SystemException would be thrown when passing\n * null to methods expected a valid instance. Javascript has no such\n * concept, but TypeScript will not allow `null` to be passed to methods\n * explicitely requiring a valid type.\n *\n * Whenever TypeScript complain about the possibility of a `null` value,\n * check the offending value and it it's null, throw this exception using\n * `throwNullException(name: string)`.\n */\nexport class NullException extends Error{}\n\n/**\n * Throw a NullException.\n * @param name a short description of the offending value (often its name within the code).\n */\nexport function throwNullException(name: string): never {\n\tthrow new NullException(`${name} is null or undefined`);\n}\n","import {Path} from './Path';\nimport {Container} from './Container';\nimport {Debug} from './Debug';\nimport {asOrNull, asINamedContentOrNull} from './TypeAssertion';\nimport { throwNullException } from './NullException';\nimport { SearchResult } from './SearchResult';\nimport { DebugMetadata } from './DebugMetadata';\n\nexport class InkObject{\n\n\tpublic parent: InkObject | null = null;\n\n\tget debugMetadata(): DebugMetadata | null {\n\t\tif (this._debugMetadata === null) {\n\t\t\tif (this.parent) {\n\t\t\t\treturn this.parent.debugMetadata;\n\t\t\t}\n\t\t}\n\n\t\treturn this._debugMetadata;\n\t}\n\n\tset debugMetadata(value) {\n\t\tthis._debugMetadata = value;\n\t}\n\n\tget ownDebugMetadata() {\n\t\treturn this._debugMetadata;\n\t}\n\n\tprivate _debugMetadata: DebugMetadata | null = null;\n\n\tpublic DebugLineNumberOfPath(path: Path) {\n\t\tif (path === null)\n\t\t\treturn null;\n\n\t\t// Try to get a line number from debug metadata\n\t\tlet root = this.rootContentContainer;\n\t\tif (root) {\n\t\t\tlet targetContent = root.ContentAtPath(path).obj;\n\t\t\tif (targetContent) {\n\t\t\t\tlet dm = targetContent.debugMetadata;\n\t\t\t\tif (dm !== null) {\n\t\t\t\t\treturn dm.startLineNumber;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tget path(){\n\t\tif (this._path == null) {\n\n\t\t\tif (this.parent == null) {\n\t\t\t\tthis._path = new Path();\n\t\t\t} else {\n\t\t\t\tlet comps: Path.Component[] = [];\n\n\t\t\t\tlet child: InkObject = this;\n\t\t\t\tlet container = asOrNull(child.parent, Container);\n\n\t\t\t\twhile (container !== null) {\n\n\t\t\t\t\tlet namedChild = asINamedContentOrNull(child);\n\t\t\t\t\tif (namedChild != null && namedChild.hasValidName) {\n\t\t\t\t\t\tcomps.unshift(new Path.Component(namedChild.name));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcomps.unshift(new Path.Component(container.content.indexOf(child)));\n\t\t\t\t\t}\n\n\t\t\t\t\tchild = container;\n\t\t\t\t\tcontainer = asOrNull(container.parent, Container);\n\t\t\t\t}\n\n\t\t\t\tthis._path = new Path(comps);\n\t\t\t}\n\n\t\t}\n\n\t\treturn this._path;\n\t}\n\tprivate _path: Path | null = null;\n\n\tpublic ResolvePath(path: Path | null): SearchResult{\n\t\tif (path === null) return throwNullException('path');\n\t\tif (path.isRelative) {\n\t\t\tlet nearestContainer = asOrNull(this, Container);\n\n\t\t\tif (nearestContainer === null) {\n\t\t\t\tDebug.Assert(this.parent !== null, \"Can't resolve relative path because we don't have a parent\");\n\t\t\t\tnearestContainer = asOrNull(this.parent, Container);\n\t\t\t\tDebug.Assert(nearestContainer !== null, 'Expected parent to be a container');\n\t\t\t\tDebug.Assert(path.GetComponent(0).isParent);\n\t\t\t\tpath = path.tail;\n\t\t\t}\n\n\t\t\tif (nearestContainer === null) { return throwNullException('nearestContainer'); }\n\t\t\treturn nearestContainer.ContentAtPath(path);\n\t\t} else {\n\t\t\tlet contentContainer = this.rootContentContainer;\n\t\t\tif (contentContainer === null) { return throwNullException('contentContainer'); }\n\t\t\treturn contentContainer.ContentAtPath(path);\n\t\t}\n\t}\n\n\tpublic ConvertPathToRelative(globalPath: Path){\n\t\tlet ownPath = this.path;\n\n\t\tlet minPathLength = Math.min(globalPath.length, ownPath.length);\n\t\tlet lastSharedPathCompIndex = -1;\n\n\t\tfor (let i = 0; i < minPathLength; ++i) {\n\t\t\tlet ownComp = ownPath.GetComponent(i);\n\t\t\tlet otherComp = globalPath.GetComponent(i);\n\n\t\t\tif (ownComp.Equals(otherComp)) {\n\t\t\t\tlastSharedPathCompIndex = i;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// No shared path components, so just use global path\n\t\tif (lastSharedPathCompIndex == -1)\n\t\t\treturn globalPath;\n\n\t\tlet numUpwardsMoves = (ownPath.componentCount-1) - lastSharedPathCompIndex;\n\n\t\tlet newPathComps: Path.Component[] = [];\n\n\t\tfor(let up = 0; up < numUpwardsMoves; ++up)\n\t\t\tnewPathComps.push(Path.Component.ToParent());\n\n\t\tfor (let down = lastSharedPathCompIndex + 1; down < globalPath.componentCount; ++down)\n\t\t\tnewPathComps.push(globalPath.GetComponent(down));\n\n\t\tlet relativePath = new Path(newPathComps, true);\n\t\treturn relativePath;\n\t}\n\n\tpublic CompactPathString(otherPath: Path){\n\t\tlet globalPathStr = null;\n\t\tlet relativePathStr = null;\n\n\t\tif (otherPath.isRelative) {\n\t\t\trelativePathStr = otherPath.componentsString;\n\t\t\tglobalPathStr = this.path.PathByAppendingPath(otherPath).componentsString;\n\t\t}\n\t\telse {\n\t\t\tlet relativePath = this.ConvertPathToRelative(otherPath);\n\t\t\trelativePathStr = relativePath.componentsString;\n\t\t\tglobalPathStr = otherPath.componentsString;\n\t\t}\n\n\t\tif (relativePathStr.length < globalPathStr.length)\n\t\t\treturn relativePathStr;\n\t\telse\n\t\t\treturn globalPathStr;\n\t}\n\n\tget rootContentContainer(){\n\t\tlet ancestor: InkObject = this;\n\t\twhile (ancestor.parent) {\n\t\t\tancestor = ancestor.parent;\n\t\t}\n\t\treturn asOrNull(ancestor, Container);\n\t}\n\n\tpublic Copy(): InkObject {\n\t\tthrow Error(\"Not Implemented: Doesn't support copying\");\n\t}\n\t// SetChild works slightly diferently in the js implementation.\n\t// Since we can't pass an objets property by reference, we instead pass\n\t// the object and the property string.\n\t// TODO: This method can probably be rewritten with type-safety in mind.\n\tpublic SetChild(obj: any, prop: any, value: any){\n\t\tif (obj[prop])\n\t\t\tobj[prop] = null;\n\n\t\tobj[prop] = value;\n\n\t\tif( obj[prop] )\n\t\t\tobj[prop].parent = this;\n\t}\n}\n","export class StringBuilder{\n\n\tprivate string: string;\n\n\tconstructor(str?: string){\n\t\tstr = (typeof str !== 'undefined') ? str.toString() : '';\n\t\tthis.string = str;\n\t}\n\tget Length(): number{\n\t\treturn this.string.length;\n\t}\n\tpublic Append(str: string | null){\n\t\tif (str !== null) {\n\t\t\tthis.string += str;\n\t\t}\n\t}\n\tpublic AppendLine(str?: string){\n\t\tif (typeof str !== 'undefined') this.Append(str);\n\t\tthis.string += '\\n';\n\t}\n\tpublic AppendFormat(format: string, ...args: any[]){\n\t\t// taken from http://stackoverflow.com/questions/610406/javascript-equivalent-to-printf-string-format\n\t\tthis.string += format.replace(/{(\\d+)}/g, (match: string, num: number) => {\n\t\t\treturn typeof args[num] != 'undefined' ? args[num] : match;\n\t\t});\n\t}\n\tpublic toString(): string{\n\t\treturn this.string;\n\t}\n}\n","import {throwNullException} from './NullException';\nimport {StringBuilder} from './StringBuilder';\nimport {ListDefinition} from './ListDefinition';\nimport {Story} from './Story';\n\nexport class InkListItem implements IInkListItem{ // InkListItem is a struct\n\n\tpublic readonly originName: string | null = null;\n\tpublic readonly itemName: string | null = null;\n\n\tconstructor(originName: string | null, itemName: string | null)\n\tconstructor(fullName: string | null)\n\tconstructor(){\n\t\tif (typeof arguments[1] !== 'undefined'){\n\t\t\tlet originName = arguments[0] as string | null;\n\t\t\tlet itemName = arguments[1] as string | null;\n\n\t\t\tthis.originName = originName;\n\t\t\tthis.itemName = itemName;\n\t\t}\n\t\telse if (arguments[0]){\n\t\t\tlet fullName = arguments[0] as string;\n\n\t\t\tlet nameParts = fullName.toString().split('.');\n\t\t\tthis.originName = nameParts[0];\n\t\t\tthis.itemName = nameParts[1];\n\t\t}\n\t}\n\tpublic static get Null(){\n\t\treturn new InkListItem(null, null);\n\t}\n\tpublic get isNull(){\n\t\treturn this.originName == null && this.itemName == null;\n\t}\n\tget fullName(){\n\t\treturn ((this.originName !== null) ? this.originName : '?') + '.' + this.itemName;\n\t}\n\tpublic toString(): string {\n\t\treturn this.fullName;\n\t}\n\tpublic Equals(obj: InkListItem){\n\t\tif (obj instanceof InkListItem) {\n\t\t\tlet otherItem = obj;\n\t\t\treturn otherItem.itemName == this.itemName\n\t\t\t\t&& otherItem.originName == this.originName;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t// These methods did not exist in the original C# code. Their purpose is to\n\t// make `InkListItem` mimics the value-type semantics of the original\n\t// struct. Please refer to the end of this file, for a more in-depth\n\t// explanation.\n\n\t/**\n\t * Returns a shallow clone of the current instance.\n\t */\n\tpublic copy(){\n\t\treturn new InkListItem(this.originName, this.itemName);\n\t}\n\t/**\n\t * Returns a `SerializedInkListItem` representing the current\n\t * instance. The result is intended to be used as a key inside a Map.\n\t */\n\tpublic serialized(): SerializedInkListItem{\n\t\t// We are simply using a JSON representation as a value-typed key.\n\t\treturn JSON.stringify({originName: this.originName, itemName: this.itemName});\n\t}\n\n\t/**\n\t * Reconstructs a `InkListItem` from the given SerializedInkListItem.\n\t */\n\tpublic static fromSerializedKey(key: SerializedInkListItem): InkListItem {\n\t\tlet obj = JSON.parse(key);\n\t\tif (!InkListItem.isLikeInkListItem(obj)) return InkListItem.Null;\n\n\t\tlet inkListItem = obj as IInkListItem;\n\n\t\treturn new InkListItem(inkListItem.originName, inkListItem.itemName);\n\t}\n\n\t/**\n\t * Determines whether the given item is sufficiently `InkListItem`-like\n\t * to be used as a template when reconstructing the InkListItem.\n\t */\n\tprivate static isLikeInkListItem(item: any){\n\t\tif (typeof item !== 'object') return false;\n\t\tif (!item.hasOwnProperty('originName') || !item.hasOwnProperty('itemName')) return false;\n\t\tif (typeof item.originName !== 'string' && typeof item.originName !== null) return false;\n\t\tif (typeof item.itemName !== 'string' && typeof item.itemName !== null) return false;\n\n\t\treturn true;\n\t}\n}\n\nexport class InkList extends Map<SerializedInkListItem, number> {\n\tpublic origins: ListDefinition[] | null = null;\n\tpublic _originNames: string[] | null = [];\n\n\tconstructor()\n\tconstructor(otherList: InkList)\n\tconstructor(singleOriginListName: string, originStory: Story)\n\tconstructor(singleElement: KeyValuePair<InkListItem, number>)\n\tconstructor(){\n\t\t// Trying to be smart here, this emulates the constructor inheritance found\n\t\t// in the original code, but only if otherList is an InkList. IIFE FTW.\n\t\tsuper((() => {\n\t\t\tif (arguments[0] instanceof InkList){\n\t\t\t\treturn arguments[0];\n\t\t\t}\n\t\t\telse{\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t})());\n\n\t\tif (arguments[0] instanceof InkList){\n\t\t\tlet otherList = arguments[0] as InkList;\n\n\t\t\tif (otherList._originNames) {\n\t\t\t\tthis._originNames = otherList._originNames.slice();\n\t\t\t}\n\t\t}\n\t\telse if (typeof arguments[0] === 'string'){\n\t\t\tlet singleOriginListName = arguments[0] as string;\n\t\t\tlet originStory = arguments[1] /* as Story */;\n\t\t\tthis.SetInitialOriginName(singleOriginListName);\n\n\t\t\tlet def = originStory.listDefinitions.TryListGetDefinition(singleOriginListName, null);\n\t\t\tif (def.exists){\n\t\t\t\tthis.origins = [def.result];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tthrow new Error('InkList origin could not be found in story when constructing new list: ' + singleOriginListName);\n\t\t\t}\n\t\t}\n\t\telse if (typeof arguments[0] === 'object' && arguments[0].hasOwnProperty('Key') && arguments[0].hasOwnProperty('Value')){\n\t\t\tlet singleElement = arguments[0] as KeyValuePair<InkListItem, number>;\n\t\t\tthis.Add(singleElement.Key, singleElement.Value);\n\t\t}\n\t}\n\n\tpublic AddItem(itemOrItemName: InkListItem | string | null){\n\t\tif (itemOrItemName instanceof InkListItem){\n\t\t\tlet item = itemOrItemName;\n\n\t\t\tif (item.originName == null) {\n\t\t\t\tthis.AddItem(item.itemName);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (this.origins === null) return throwNullException('this.origins');\n\n\t\t\tfor (let origin of this.origins) {\n\t\t\t\tif (origin.name == item.originName) {\n\t\t\t\t\tlet intVal = origin.TryGetValueForItem(item, 0);\n\t\t\t\t\tif (intVal.exists) {\n\t\t\t\t\t\tthis.Add(item, intVal.result);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error('Could not add the item ' + item + \" to this list because it doesn't exist in the original list definition in ink.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthrow new Error(\"Failed to add item to list because the item was from a new list definition that wasn't previously known to this list. Only items from previously known lists can be used, so that the int value can be found.\");\n\t\t}\n\t\telse {\n\t\t\tlet itemName = itemOrItemName as string | null;\n\n\t\t\tlet foundListDef: ListDefinition | null = null;\n\n\t\t\tif (this.origins === null) return throwNullException('this.origins');\n\n\t\t\tfor (let origin of this.origins) {\n\t\t\t\tif (itemName === null) return throwNullException('itemName');\n\n\t\t\t\tif (origin.ContainsItemWithName(itemName)) {\n\t\t\t\t\t\tif (foundListDef != null) {\n\t\t\t\t\t\t\tthrow new Error('Could not add the item ' + itemName + ' to this list because it could come from either ' + origin.name + ' or ' + foundListDef.name);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfoundListDef = origin;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (foundListDef == null)\n\t\t\t\tthrow new Error('Could not add the item ' + itemName + \" to this list because it isn't known to any list definitions previously associated with this list.\");\n\n\t\t\tlet item = new InkListItem(foundListDef.name, itemName);\n\t\t\tlet itemVal = foundListDef.ValueForItem(item);\n\t\t\tthis.Add(item, itemVal);\n\t\t}\n\t}\n\tpublic ContainsItemNamed(itemName: string | null){\n\t\tfor (let [key, value] of this) {\n\t\t\tlet item = InkListItem.fromSerializedKey(key);\n\t\t\tif (item.itemName == itemName) return true;\n\t\t}\n\n\t\treturn false;\n\t}\n\tpublic ContainsKey(key: InkListItem){\n\t\treturn this.has(key.serialized());\n\t}\n\tpublic Add(key: InkListItem, value: number){\n\t\tlet serializedKey = key.serialized();\n\t\tif (this.has(serializedKey)) {\n\t\t\t// Throw an exception to match the C# behavior.\n\t\t\tthrow new Error(`The Map already contains an entry for ${key}`);\n\t\t}\n\t\tthis.set(serializedKey, value);\n\t}\n\tpublic Remove(key: InkListItem){\n\t\treturn this.delete(key.serialized());\n\t}\n\tget Count(){\n\t\treturn this.size;\n\t}\n\tget originOfMaxItem(): ListDefinition | null{\n\t\tif (this.origins == null) return null;\n\n\t\tlet maxOriginName = this.maxItem.Key.originName;\n\t\tlet result = null;\n\t\tthis.origins.every((origin)=>{\n\t\t\tif (origin.name == maxOriginName){\n\t\t\t\tresult = origin;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse return true;\n\t\t});\n\n\t\treturn result;\n\t}\n\tget originNames(): string[]{\n\t\tif (this.Count > 0) {\n\t\t\tif (this._originNames == null && this.Count > 0)\n\t\t\t\tthis._originNames = [];\n\t\t\telse {\n\t\t\t\tif (!this._originNames) this._originNames = [];\n\t\t\t\tthis._originNames.length = 0;\n\t\t\t}\n\n\t\t\tfor (let [key, value] of this) {\n\t\t\t\tlet item = InkListItem.fromSerializedKey(key);\n\t\t\t\tif (item.originName === null) return throwNullException('item.originName');\n\t\t\t\tthis._originNames.push(item.originName);\n\t\t\t}\n\t\t}\n\n\t\treturn this._originNames as string[];\n\t}\n\tpublic SetInitialOriginName(initialOriginName: string){\n\t\tthis._originNames = [initialOriginName];\n\t}\n\tpublic SetInitialOriginNames(initialOriginNames: string[]){\n\t\tif (initialOriginNames == null)\n\t\t\tthis._originNames = null;\n\t\telse\n\t\t\tthis._originNames = initialOriginNames.slice();// store a copy\n\t}\n\tget maxItem(){\n\t\tlet max: KeyValuePair<InkListItem, number> = {\n\t\t\tKey: InkListItem.Null,\n\t\t\tValue: 0,\n\t\t};\n\t\tfor (let [key, value] of this) {\n\t\t\tlet item = InkListItem.fromSerializedKey(key);\n\t\t\tif (max.Key.isNull || value > max.Value)\n\t\t\t\tmax = { Key: item, Value: value };\n\t\t}\n\n\t\treturn max;\n\t}\n\tget minItem(){\n\t\tlet min: KeyValuePair<InkListItem, number> = {\n\t\t\tKey: InkListItem.Null,\n\t\t\tValue: 0,\n\t\t};\n\t\tfor (let [key, value] of this) {\n\t\t\tlet item = InkListItem.fromSerializedKey(key);\n\t\t\tif (min.Key.isNull || value < min.Value) {\n\t\t\t\tmin = { Key: item, Value: value };\n\t\t\t}\n\t\t}\n\t\treturn min;\n\t}\n\tget inverse(){\n\t\tlet list = new InkList();\n\t\tif (this.origins != null) {\n\t\t\tfor (let origin of this.origins) {\n\t\t\t\tfor (let [key, value] of origin.items) {\n\t\t\t\t\tlet item = InkListItem.fromSerializedKey(key);\n\t\t\t\t\tif (!this.ContainsKey(item))\n\t\t\t\t\t\tlist.Add(item, value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t}\n\tget all(){\n\t\tlet list = new InkList();\n\t\tif (this.origins != null) {\n\t\t\tfor(let origin of this.origins) {\n\t\t\t\tfor (let [key, value] of origin.items) {\n\t\t\t\t\tlet item = InkListItem.fromSerializedKey(key);\n\t\t\t\t\tlist.set(item.serialized(), value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t}\n\tpublic Union(otherList: InkList){\n\t\tlet union = new InkList(this);\n\t\tfor(let [key, value] of otherList) {\n\t\t\tunion.set(key, value);\n\t\t}\n\t\treturn union;\n\t}\n\tpublic Intersect(otherList: InkList){\n\t\tlet intersection = new InkList();\n\t\tfor(let [key, value] of this) {\n\t\t\tif (otherList.has(key))\n\t\t\t\tintersection.set(key, value);\n\t\t}\n\n\t\treturn intersection;\n\t}\n\tpublic Without(listToRemove: InkList){\n\t\tlet result = new InkList(this);\n\t\tfor(let [key, value] of listToRemove) {\n\t\t\tresult.delete(key);\n\t\t}\n\n\t\treturn result;\n\t}\n\tpublic Contains(otherList: InkList){\n\t\tfor(let [key, value] of otherList) {\n\t\t\tif (!this.has(key)) return false;\n\t\t}\n\n\t\treturn true;\n\t}\n\tpublic GreaterThan(otherList: InkList){\n\t\tif (this.Count == 0) return false;\n\t\tif (otherList.Count == 0) return true;\n\n\t\treturn this.minItem.Value > otherList.maxItem.Value;\n\t}\n\tpublic GreaterThanOrEquals(otherList: InkList){\n\t\tif (this.Count == 0) return false;\n\t\tif (otherList.Count == 0) return true;\n\n\t\treturn this.minItem.Value >= otherList.minItem.Value\n\t\t\t&& this.maxItem.Value >= otherList.maxItem.Value;\n\t}\n\tpublic LessThan(otherList: InkList){\n\t\tif (otherList.Count == 0) return false;\n\t\tif (this.Count == 0) return true;\n\n\t\treturn this.maxItem.Value < otherList.minItem.Value;\n\t}\n\tpublic LessThanOrEquals(otherList: InkList){\n\t\tif (otherList.Count == 0) return false;\n\t\tif (this.Count == 0) return true;\n\n\t\treturn this.maxItem.Value <= otherList.maxItem.Value\n\t\t\t&& this.minItem.Value <= otherList.minItem.Value;\n\t}\n\tpublic MaxAsList(){\n\t\tif (this.Count > 0)\n\t\t\treturn new InkList(this.maxItem);\n\t\telse\n\t\t\treturn new InkList();\n\t}\n\tpublic MinAsList(){\n\t\tif (this.Count > 0)\n\t\t\treturn new InkList(this.minItem);\n\t\telse\n\t\t\treturn new InkList();\n\t}\n\tpublic ListWithSubRange(minBound: any, maxBound: any)\n\t{\n\t\tif (this.Count == 0) return new InkList();\n\n\t\tlet ordered = this.orderedItems;\n\n\t\tlet minValue = 0;\n\t\tlet maxValue = Number.MAX_SAFE_INTEGER;\n\n\t\tif (Number.isInteger(minBound)) {\n\t\t\tminValue = minBound;\n\t\t} else {\n\t\t\tif (minBound instanceof InkList && minBound.Count > 0 )\n\t\t\t\tminValue = minBound.minItem.Value;\n\t\t}\n\n\t\tif (Number.isInteger(maxBound)) {\n\t\t\tmaxValue = maxBound;\n\t\t} else {\n\t\t\tif (minBound instanceof InkList && (minBound).Count > 0)\n\t\t\t\tmaxValue = maxBound.maxItem.Value;\n\t\t}\n\n\t\tlet subList = new InkList();\n\t\tsubList.SetInitialOriginNames(this.originNames);\n\t\tfor (let item of ordered) {\n\t\t\tif (item.Value >= minValue && item.Value <= maxValue ) {\n\t\t\t\tsubList.Add(item.Key, item.Value);\n\t\t\t}\n\t\t}\n\n\t\treturn subList;\n\t}\n\tpublic Equals(otherInkList: InkList){\n\t\tif (otherInkList instanceof InkList === false) return false;\n\t\tif (otherInkList.Count != this.Count) return false;\n\n\t\tfor(let [key, value] of this) {\n\t\t\tif (!otherInkList.has(key))\n\t\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\t// GetHashCode not implemented\n\tget orderedItems() {\n\t\t// List<KeyValuePair<InkListItem, int>>\n\t\tlet ordered = new Array<KeyValuePair<InkListItem, number>>();\n\n\t\tfor(let [key, value] of this) {\n\t\t\tlet item = InkListItem.fromSerializedKey(key);\n\t\t\tordered.push({ Key: item, Value: value });\n\t\t}\n\n\t\tordered.sort((x, y) => {\n\t\t\tif (x.Key.originName === null) { return throwNullException('x.Key.originName'); }\n\t\t\tif (y.Key.originName === null) { return throwNullException('y.Key.originName'); }\n\n\t\t\tif (x.Value == y.Value) {\n\t\t\t\treturn x.Key.originName.localeCompare(y.Key.originName);\n\t\t\t} else {\n\t\t\t\t// TODO: refactor this bit into a numberCompareTo method?\n\t\t\t\tif (x.Value < y.Value)\n\t\t\t\t\treturn -1;\n\t\t\t\treturn x.Value > y.Value ? 1 : 0;\n\t\t\t}\n\t\t});\n\n\t\treturn ordered;\n\t}\n\tpublic toString(){\n\t\tlet ordered = this.orderedItems;\n\n\t\tlet sb = new StringBuilder();\n\t\tfor (let i = 0; i < ordered.length; i++) {\n\t\t\tif (i > 0)\n\t\t\t\tsb.Append(', ');\n\n\t\t\tlet item = ordered[i].Key;\n\t\t\tif (item.itemName === null) return throwNullException('item.itemName');\n\t\t\tsb.Append(item.itemName);\n\t\t}\n\n\t\treturn sb.toString();\n\t}\n\t// casting a InkList to a Number, for somereason, actually gives a number.\n\t// This messes up the type detection when creating a Value from a InkList.\n\t// Returning NaN here prevents that.\n\tpublic valueOf(){\n\t\treturn NaN;\n\t}\n}\n\n/**\n * In the original C# code, `InkListItem` was defined as value type, meaning\n * that two `InkListItem` would be considered equal as long as they held the\n * same values. This doesn't hold true in Javascript, as `InkListItem` is a\n * reference type (Javascript doesn't allow the creation of custom value types).\n *\n * The key equality of Map objects is based on the \"SameValueZero\" algorithm;\n * since `InkListItem` is a value type, two keys will only be considered\n * equal if they are, in fact, the same object. As we are trying to emulate\n * the original behavior as close as possible, this will lead to unforeseen\n * side effects.\n *\n * In order to have a key equality based on value semantics, we'll convert\n * `InkListItem` to a valid string representation and use this representation\n * as a key (strings are value types in Javascript). Rather than using the\n * type `string` directly, we'll alias it to `SerializedInkListItem` and use\n * this type as the key for our Map-based `InkList`.\n *\n * Reducing `InkListItem` to a JSON representation would not be bulletproof\n * in the general case, but for our needs it works well. The major downside of\n * this method is that we will have to to reconstruct the original `InkListItem`\n * every time we'll need to access its properties.\n */\nexport type SerializedInkListItem = string;\n\n/**\n * An interface inherited by `InkListItem`, defining exposed\n * properties. It's mainly used when deserializing a `InkListItem` from its\n * key (`SerializedInkListItem`)\n */\ninterface IInkListItem{\n\treadonly originName: string | null;\n\treadonly itemName: string | null;\n}\nexport interface KeyValuePair<K, V> {\n\tKey: K;\n\tValue: V;\n}\n","export class StoryException extends Error{\n\n\tpublic useEndLineNumber: boolean;\n\tpublic message: string;\n\tpublic name: string;\n\n\tconstructor(message: string){\n\t\tsuper(message);\n\t\tthis.useEndLineNumber = false;\n\t\tthis.message = message;\n\t\tthis.name = 'StoryException';\n\t}\n}\n","// tslint:disable:jsdoc-format\n/**\n * This interface normalize the `TryGet` behavior found in the original\n * C# project. Any `TryGet` method will return a object conforming to this\n * interface.\n *\n * The original function returns a boolean and has a second parameter called\n * item that is an `out`. Both are needed and we can't just return the item\n * because it'll always be truthy. Instead, we return an object containing\n * whether the result exists (`exists`) and the result itself (`result`).\n *\n * For instance a `TryGet` prototype would look like this:\n```\nTryGetItemWithValue(val: number, item: InkListItem): TryGetResult<InkListItem>{\n```\n *\n * On the other hand, dealing with the result can be done in the following way:\n```\nvar item = item.TryGetItemWithValue(intVal, InkListItem.Null);\nif (item.exists) {\n\tconsole.log(item.result)\n}\n```\n *\n */\nexport interface TryGetResult<T> {\n\tresult: T;\n\texists: boolean;\n}\n\nexport function tryGetValueFromMap<K, V>(map: Map<K, V> | null, key: K, /* out */ value: V): TryGetResult<V> {\n\tif (map === null) {\n\t\treturn { result: value, exists: false };\n\t}\n\n\tlet val = map.get(key);\n\n\tif (val) {\n\t\treturn { result: val, exists: true };\n\t} else {\n\t\treturn { result: value, exists: false };\n\t}\n}\n\nexport function tryParseInt(value: any, /* out */ defaultValue: number = 0): TryGetResult<number> {\n\tlet val = parseInt(value);\n\n\tif (!Number.isNaN(val)) {\n\t\treturn { result: val, exists: true };\n\t} else {\n\t\treturn { result: defaultValue, exists: false };\n\t}\n}\n\nexport function tryParseFloat(value: any, /* out */ defaultValue: number = 0): TryGetResult<number> {\n\tlet val = parseFloat(value);\n\n\tif (!Number.isNaN(val)) {\n\t\treturn { result: val, exists: true };\n\t} else {\n\t\treturn { result: defaultValue, exists: false };\n\t}\n}\n","import {InkObject} from './Object';\nimport {Path} from './Path';\nimport {InkList, InkListItem} from './InkList';\nimport {StoryException} from './StoryException';\nimport {asOrNull, asOrThrows} from './TypeAssertion';\nimport {tryParseInt, tryParseFloat} from './TryGetResult';\nimport {throwNullException} from './NullException';\n\nexport abstract class AbstractValue extends InkObject{\n\tpublic abstract get valueType(): ValueType;\n\tpublic abstract get isTruthy(): boolean;\n\tpublic abstract get valueObject(): any;\n\n\tpublic abstract Cast(newType: ValueType): Value<any>;\n\n\tpublic static Create(val: any): Value<any> | null{\n\t\t// Implicitly convert bools into ints\n\t\tif (typeof val === 'boolean'){\n\t\t\tlet b = !!val;\n\t\t\tval = (b) ? 1 : 0;\n\t\t}\n\n\t\t// https://github.com/y-lohse/inkjs/issues/425\n\t\t// Changed condition sequence, because Number('') is\n\t\t// parsed to 0, which made setting string to empty\n\t\t// impossible\n\t\tif (typeof val === 'string') {\n\t\t\treturn new StringValue(String(val));\n\t\t} else if (Number.isInteger(Number(val))) {\n\t\t\treturn new IntValue(Number(val));\n\t\t} else if (!isNaN(val)) {\n\t\t\treturn new FloatValue(Number(val));\n\t\t} else if (val instanceof Path) {\n\t\t\treturn new DivertTargetValue(asOrThrows(val, Path));\n\t\t} else if (val instanceof InkList) {\n\t\t\treturn new ListValue(asOrThrows(val, InkList));\n\t\t}\n\n\t\treturn null;\n\t}\n\tpublic Copy() {\n\t\treturn asOrThrows(AbstractValue.Create(this), InkObject);\n\t}\n\tpublic BadCastException(targetType: ValueType) {\n\t\treturn new StoryException(\"Can't cast \"+this.valueObject+' from ' + this.valueType+' to '+targetType);\n\t}\n}\n\nexport abstract class Value<T extends { toString: () => string; }> extends AbstractValue{\n\tpublic value: T | null;\n\n\tconstructor(val: T | null){\n\t\tsuper();\n\t\tthis.value = val;\n\t}\n\tpublic get valueObject(){\n\t\treturn this.value;\n\t}\n\tpublic toString(){\n\t\tif (this.value === null) return throwNullException('Value.value');\n\t\treturn this.value.toString();\n\t}\n}\n\nexport class IntValue extends Value<number>{\n\tconstructor(val: number){\n\t\tsuper(val || 0);\n\t}\n\tpublic get isTruthy(){\n\t\treturn this.value != 0;\n\t}\n\tpublic get valueType() {\n\t\treturn ValueType.Int;\n\t}\n\n\tpublic Cast(newType: ValueType): Value<any>{\n\t\tif (this.value === null) return throwNullException('Value.value');\n\n\t\tif (newType == this.valueType) {\n\t\t\treturn this;\n\t\t}\n\n\t\tif (newType == ValueType.Float) {\n\t\t\treturn new FloatValue(this.value);\n\t\t}\n\n\t\tif (newType == ValueType.String) {\n\t\t\treturn new StringValue('' + this.value);\n\t\t}\n\n\t\tthrow this.BadCastException(newType);\n\t}\n}\n\nexport class FloatValue extends Value<number>{\n\tconstructor(val: number){\n\t\tsuper(val || 0.0);\n\t}\n\tpublic get isTruthy(){\n\t\treturn this.value != 0.0;\n\t}\n\tpublic get valueType(){\n\t\treturn ValueType.Float;\n\t}\n\n\tpublic Cast(newType: ValueType): Value<any>{\n\t\tif (this.value === null) return throwNullException('Value.value');\n\n\t\tif (newType == this.valueType) {\n\t\t\treturn this;\n\t\t}\n\n\t\tif (newType == ValueType.Int) {\n\t\t\treturn new IntValue(this.value);\n\t\t}\n\n\t\tif (newType == ValueType.String) {\n\t\t\treturn new StringValue('' + this.value);\n\t\t}\n\n\t\tthrow this.BadCastException(newType);\n\t}\n}\n\nexport class StringValue extends Value<string>{\n\tpublic _isNewline: boolean;\n\tpublic _isInlineWhitespace: boolean;\n\n\tconstructor(val: string){\n\t\tsuper(val || '');\n\n\t\tthis._isNewline = (this.value == '\\n');\n\t\tthis._isInlineWhitespace = true;\n\n\t\tif (this.value === null) return throwNullException('Value.value');\n\n\t\tif (this.value.length > 0) {\n\t\t\tthis.value.split('').every((c) => {\n\t\t\t\tif (c != ' ' && c != '\\t'){\n\t\t\t\t\tthis._isInlineWhitespace = false;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\t});\n\t\t}\n\t}\n\tpublic get valueType(){\n\t\treturn ValueType.String;\n\t}\n\tpublic get isTruthy(){\n\t\tif (this.value === null) return throwNullException('Value.value');\n\t\treturn this.value.length > 0;\n\t}\n\tpublic get isNewline(){\n\t\treturn this._isNewline;\n\t}\n\tpublic get isInlineWhitespace(){\n\t\treturn this._isInlineWhitespace;\n\t}\n\tpublic get isNonWhitespace(){\n\t\treturn !this.isNewline && !this.isInlineWhitespace;\n\t}\n\n\tpublic Cast(newType: ValueType): Value<any>{\n\t\tif (newType == this.valueType) {\n\t\t\treturn this;\n\t\t}\n\n\t\tif (newType == ValueType.Int) {\n\n\t\t\tlet parsedInt = tryParseInt(this.value);\n\t\t\tif (parsedInt.exists) {\n\t\t\t\treturn new IntValue(parsedInt.result);\n\t\t\t} else {\n\t\t\t\tthrow this.BadCastException(newType);\n\t\t\t}\n\t\t}\n\n\t\tif (newType == ValueType.Float) {\n\t\t\tlet parsedFloat = tryParseFloat(this.value);\n\t\t\tif (parsedFloat.exists) {\n\t\t\t\treturn new FloatValue(parsedFloat.result);\n\t\t\t} else {\n\t\t\t\tthrow this.BadCastException(newType);\n\t\t\t}\n\t\t}\n\n\t\tthrow this.BadCastException(newType);\n\t}\n}\n\nexport class DivertTargetValue extends Value<Path>{\n\tconstructor(targetPath: Path){\n\t\tsuper(targetPath);\n\t}\n\tpublic get valueType() {\n\t\treturn ValueType.DivertTarget;\n\t}\n\tpublic get targetPath(){\n\t\tif (this.value === null) return throwNullException('Value.value');\n\t\treturn this.value;\n\t}\n\tpublic set targetPath(value: Path){\n\t\tthis.value = value;\n\t}\n\tpublic get isTruthy(): never{\n\t\tthrow new Error('Shouldn\\'t be checking the truthiness of a divert target');\n\t}\n\n\tpublic Cast(newType: ValueType): Value<any>{\n\t\tif (newType == this.valueType)\n\t\t\treturn this;\n\n\t\tthrow this.BadCastException(newType);\n\t}\n\tpublic toString(){\n\t\treturn 'DivertTargetValue(' + this.targetPath + ')';\n\t}\n}\n\nexport class VariablePointerValue extends Value<string>{\n\tpublic _contextIndex: number;\n\n\tconstructor(variableName: string, contextIndex: number = -1){\n\t\tsuper(variableName);\n\n\t\tthis._contextIndex = contextIndex;\n\t}\n\n\tpublic get contextIndex(){\n\t\treturn this._contextIndex;\n\t}\n\tpublic set contextIndex(value: number) {\n\t\tthis._contextIndex = value;\n\t}\n\tpublic get variableName(){\n\t\tif (this.value === null) return throwNullException('Value.value');\n\t\treturn this.value;\n\t}\n\tpublic set variableName(value: string){\n\t\tthis.value = value;\n\t}\n\tpublic get valueType() {\n\t\treturn ValueType.VariablePointer;\n\t}\n\n\tpublic get isTruthy(): never{\n\t\tthrow new Error(\"Shouldn't be checking the truthiness of a variable pointer\");\n\t}\n\n\tpublic Cast(newType: ValueType): Value<any>{\n\t\tif (newType == this.valueType)\n\t\t\treturn this;\n\n\t\tthrow this.BadCastException(newType);\n\t}\n\tpublic toString(){\n\t\treturn 'VariablePointerValue(' + this.variableName + ')';\n\t}\n\tpublic Copy(){\n\t\treturn new VariablePointerValue(this.variableName, this.contextIndex);\n\t}\n}\n\nexport class ListValue extends Value<InkList>{\n\tpublic get isTruthy(){\n\t\tif (this.value === null) { return throwNullException('this.value'); }\n\t\treturn this.value.Count > 0;\n\t}\n\tpublic get valueType() {\n\t\treturn ValueType.List;\n\t}\n\tpublic Cast(newType: ValueType): Value<any>{\n\t\tif (this.value === null) return throwNullException('Value.value');\n\n\t\tif (newType == ValueType.Int) {\n\t\t\tlet max = this.value.maxItem;\n\t\t\tif( max.Key.isNull )\n\t\t\treturn new IntValue(0);\n\t\t\telse\n\t\t\treturn new IntValue(max.Value);\n\t\t}\n\t\telse if (newType == ValueType.Float) {\n\t\t\tlet max = this.value.maxItem;\n\t\t\tif (max.Key.isNull)\n\t\t\treturn new FloatValue(0.0);\n\t\t\telse\n\t\t\treturn new FloatValue(max.Value);\n\t\t}\n\t\telse if (newType == ValueType.String) {\n\t\t\tlet max = this.value.maxItem;\n\t\t\tif (max.Key.isNull)\n\t\t\treturn new StringValue('');\n\t\t\telse {\n\t\t\t\treturn new StringValue(max.Key.toString());\n\t\t\t}\n\t\t}\n\n\t\tif (newType == this.valueType) return this;\n\n\t\tthrow this.BadCastException(newType);\n\t}\n\tconstructor();\n\tconstructor(list: InkList);\n\tconstructor(listOrSingleItem: InkListItem, singleValue: number)\n\tconstructor(listOrSingleItem?: InkListItem | InkList, singleValue?: number){\n\t\tsuper(null);\n\n\t\tif (!listOrSingleItem && !singleValue) {\n\t\t\tthis.value = new InkList();\n\t\t}\n\t\telse if (listOrSingleItem instanceof InkList) {\n\t\t\tthis.value = new InkList(listOrSingleItem);\n\t\t}\n\t\telse if (listOrSingleItem instanceof InkListItem && typeof singleValue === 'number') {\n\t\t\tthis.value = new InkList({\n\t\t\t\tKey: listOrSingleItem,\n\t\t\t\tValue: singleValue,\n\t\t\t});\n\t\t}\n\t}\n\tpublic static RetainListOriginsForAssignment(oldValue: InkObject | null, newValue: InkObject){\n\t\tlet oldList = asOrNull(oldValue, ListValue);\n\t\tlet newList = asOrNull(newValue, ListValue);\n\n\t\tif (newList && newList.value === null) return throwNullException('newList.value');\n\t\tif (oldList && oldList.value === null) return throwNullException('oldList.value');\n\n\t\t// When assigning the empty list, try to retain any initial origin names\n\t\tif (oldList && newList && newList.value!.Count == 0)\n\t\t\tnewList.value!.SetInitialOriginNames(oldList.value!.originNames);\n\t}\n}\n\nexport enum ValueType {\n\tInt = 0,\n\tFloat = 1,\n\tList = 2,\n\tString = 3,\n\tDivertTarget = 4,\n\tVariablePointer = 5,\n}\n","import {StringValue} from './Value';\nimport {throwNullException} from './NullException';\nimport {StringBuilder} from './StringBuilder';\nimport {INamedContent} from './INamedContent';\nimport {InkObject} from './Object';\nimport {SearchResult} from './SearchResult';\nimport {Path} from './Path';\nimport {Debug} from './Debug';\nimport {tryGetValueFromMap} from './TryGetResult';\nimport {asINamedContentOrNull, asOrNull, asOrThrows} from './TypeAssertion';\n\nexport class Container extends InkObject implements INamedContent{\n\tpublic name: string = '';\n\n\tpublic _content: InkObject[] = [];\n\tpublic namedContent: Map<string, INamedContent> = new Map();\n\n\tpublic visitsShouldBeCounted: boolean = false;\n\tpublic turnIndexShouldBeCounted: boolean = false;\n\tpublic countingAtStartOnly: boolean = false;\n\n\tpublic _pathToFirstLeafContent: Path | null = null;\n\n\tget hasValidName(){\n\t\treturn this.name != null && this.name.length > 0;\n\t}\n\tget content(){\n\t\treturn this._content;\n\t}\n\tset content(value: InkObject[]){\n\t\tthis.AddContent(value);\n\t}\n\tget namedOnlyContent(){\n\t\tlet namedOnlyContentDict: Map<string, InkObject> | null = new Map();\n\n\t\tfor (let [key, value] of this.namedContent){\n\t\t\tlet inkObject = asOrThrows(value, InkObject);\n\t\t\tnamedOnlyContentDict.set(key, inkObject);\n\t\t}\n\n\t\tfor (let c of this.content){\n\t\t\tlet named = asINamedContentOrNull(c);\n\t\t\tif (named != null && named.hasValidName) {\n\t\t\t\tnamedOnlyContentDict.delete(named.name);\n\t\t\t}\n\t\t}\n\n\t\tif (namedOnlyContentDict.size == 0)\n\t\t\tnamedOnlyContentDict = null;\n\n\t\treturn namedOnlyContentDict;\n\t}\n\tset namedOnlyContent(value: Map<string, InkObject> | null){\n\t\tlet existingNamedOnly = this.namedOnlyContent;\n\t\tif (existingNamedOnly != null) {\n\t\t\tfor (let [key, val] of existingNamedOnly){\n\t\t\t\tthis.namedContent.delete(key);\n\t\t\t}\n\t\t}\n\n\t\tif (value == null)\n\t\t\treturn;\n\n\t\tfor (let [key, val] of value){\n\t\t\tlet named = asINamedContentOrNull(val);\n\t\t\tif (named != null)\n\t\t\t\tthis.AddToNamedContentOnly(named);\n\t\t}\n\t}\n\tget countFlags(): number{\n\t\tlet flags: Container.CountFlags = 0;\n\t\tif (this.visitsShouldBeCounted)    flags |= Container.CountFlags.Visits;\n\t\tif (this.turnIndexShouldBeCounted) flags |= Container.CountFlags.Turns;\n\t\tif (this.countingAtStartOnly)      flags |= Container.CountFlags.CountStartOnly;\n\n\t\tif (flags == Container.CountFlags.CountStartOnly) {\n\t\t\tflags = 0;\n\t\t}\n\n\t\treturn flags;\n\t}\n\tset countFlags(value: number){\n\t\tlet flag: Container.CountFlags = value;\n\t\tif ((flag & Container.CountFlags.Visits) > 0) this.visitsShouldBeCounted = true;\n\t\tif ((flag & Container.CountFlags.Turns) > 0)  this.turnIndexShouldBeCounted = true;\n\t\tif ((flag & Container.CountFlags.CountStartOnly) > 0) this.countingAtStartOnly = true;\n\t}\n\tget pathToFirstLeafContent(){\n\t\tif( this._pathToFirstLeafContent == null )\n\t\t\tthis._pathToFirstLeafContent = this.path.PathByAppendingPath(this.internalPathToFirstLeafContent);\n\n\t\treturn this._pathToFirstLeafContent;\n\t}\n\tget internalPathToFirstLeafContent(){\n\t\tlet components: Path.Component[] = [];\n\t\tlet container: Container = this;\n\t\twhile (container instanceof Container) {\n\t\t\tif (container.content.length > 0) {\n\t\t\t\tcomponents.push(new Path.Component(0));\n\t\t\t\tcontainer = container.content[0] as Container;\n\t\t\t}\n\t\t}\n\t\treturn new Path(components);\n\t}\n\n\tpublic AddContent(contentObjOrList: InkObject | InkObject[]){\n\t\tif (contentObjOrList instanceof Array){\n\t\t\tlet contentList = contentObjOrList as InkObject[];\n\n\t\t\tfor (let c of contentList) {\n\t\t\t\tthis.AddContent(c);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tlet contentObj = contentObjOrList as InkObject;\n\t\t\tthis._content.push(contentObj);\n\n\t\t\tif (contentObj.parent) {\n\t\t\t\tthrow new Error('content is already in ' + contentObj.parent);\n\t\t\t}\n\n\t\t\tcontentObj.parent = this;\n\n\t\t\tthis.TryAddNamedContent(contentObj);\n\t\t}\n\t}\n\tpublic TryAddNamedContent(contentObj: InkObject){\n\t\tlet namedContentObj = asINamedContentOrNull(contentObj);\n\t\tif (namedContentObj != null && namedContentObj.hasValidName){\n\t\t\tthis.AddToNamedContentOnly(namedContentObj);\n\t\t}\n\t}\n\tpublic AddToNamedContentOnly(namedContentObj: INamedContent){\n\t\tDebug.AssertType(namedContentObj, InkObject, 'Can only add Runtime.Objects to a Runtime.Container');\n\t\tlet runtimeObj = asOrThrows(namedContentObj, InkObject);\n\t\truntimeObj.parent = this;\n\n\t\tthis.namedContent.set(namedContentObj.name, namedContentObj);\n\t}\n\tpublic ContentAtPath(path: Path, partialPathStart: number = 0, partialPathLength: number = -1){\n\t\tif (partialPathLength == -1)\n\t\t\tpartialPathLength = path.length;\n\n\t\tlet result = new SearchResult();\n\t\tresult.approximate = false;\n\n\t\tlet currentContainer: Container | null = this;\n\t\tlet currentObj: InkObject = this;\n\n\t\tfor (let i = partialPathStart; i < partialPathLength; ++i) {\n\t\t\tlet comp = path.GetComponent(i);\n\t\t\tif (currentContainer == null) {\n\t\t\t\tresult.approximate = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlet foundObj: InkObject | null = currentContainer.ContentWithPathComponent(comp);\n\n\t\t\tif (foundObj == null) {\n\t\t\t\tresult.approximate = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcurrentObj = foundObj;\n\t\t\tcurrentContainer = asOrNull(foundObj, Container);\n\t\t}\n\n\t\tresult.obj = currentObj;\n\n\t\treturn result;\n\t}\n\tpublic InsertContent(contentObj: InkObject, index: number){\n\t\tthis.content[index] = contentObj;\n\n\t\tif (contentObj.parent) {\n\t\t\tthrow new Error('content is already in ' + contentObj.parent);\n\t\t}\n\n\t\tcontentObj.parent = this;\n\n\t\tthis.TryAddNamedContent(contentObj);\n\t}\n\tpublic AddContentsOfContainer(otherContainer: Container){\n\t\tthis.content = this.content.concat(otherContainer.content);\n\n\t\tfor (let obj of otherContainer.content) {\n\t\t\tobj.parent = this;\n\t\t\tthis.TryAddNamedContent(obj);\n\t\t}\n\t}\n\tpublic ContentWithPathComponent(component: Path.Component): InkObject | null{\n\t\tif (component.isIndex) {\n\n\t\t\tif (component.index >= 0 && component.index < this.content.length) {\n\t\t\t\treturn this.content[component.index];\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t}\n\n\t\telse if (component.isParent) {\n\t\t\treturn this.parent;\n\t\t}\n\n\t\telse {\n\t\t\tif (component.name === null) { return throwNullException('component.name'); }\n\t\t\tlet foundContent = tryGetValueFromMap(this.namedContent, component.name, null);\n\t\t\tif (foundContent.exists){\n\t\t\t\treturn asOrThrows(foundContent.result, InkObject);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\tpublic BuildStringOfHierarchy(): string;\n\tpublic BuildStringOfHierarchy(sb: StringBuilder, indentation: number, pointedObj: InkObject | null): string;\n\tpublic BuildStringOfHierarchy(){\n\t\tlet sb: StringBuilder;\n\t\tif (arguments.length == 0){\n\t\t\tsb = new StringBuilder();\n\t\t\tthis.BuildStringOfHierarchy(sb, 0, null);\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tsb = arguments[0] as StringBuilder;\n\t\tlet indentation = arguments[1] as number;\n\t\tlet pointedObj = arguments[2] as InkObject | null;\n\n\t\tfunction appendIndentation(){\n\t\t\tconst spacesPerIndent = 4; // Truly const in the original code\n\t\t\tfor(let i = 0; i < spacesPerIndent*indentation; ++i) {\n\t\t\t\tsb.Append(' ');\n\t\t\t}\n\t\t}\n\n\t\tappendIndentation();\n\t\tsb.Append('[');\n\n\t\tif (this.hasValidName) {\n\t\t\tsb.AppendFormat(' ({0})', this.name);\n\t\t}\n\n\t\tif (this == pointedObj) {\n\t\t\tsb.Append('  <---');\n\t\t}\n\n\t\tsb.AppendLine();\n\n\t\tindentation++;\n\n\t\tfor (let i = 0; i < this.content.length; ++i) {\n\n\t\t\tlet obj = this.content[i];\n\n\t\t\tif (obj instanceof Container) {\n\n\t\t\t\tlet container = obj as Container;\n\n\t\t\t\tcontainer.BuildStringOfHierarchy(sb, indentation, pointedObj);\n\n\t\t\t} else {\n\t\t\t\tappendIndentation();\n\t\t\t\tif (obj instanceof StringValue) {\n\t\t\t\t\tsb.Append('\\\"');\n\t\t\t\t\tsb.Append(obj.toString().replace('\\n', '\\\\n'));\n\t\t\t\t\tsb.Append('\\\"');\n\t\t\t\t} else {\n\t\t\t\t\tsb.Append(obj.toString());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (i != this.content.length - 1) {\n\t\t\t\tsb.Append(',');\n\t\t\t}\n\n\t\t\tif ( !(obj instanceof Container) && obj == pointedObj ) {\n\t\t\t\tsb.Append('  <---');\n\t\t\t}\n\n\t\t\tsb.AppendLine();\n\t\t}\n\n\t\tlet onlyNamed: Map<string, INamedContent> = new Map();\n\n\t\tfor (let [key, value] of this.namedContent){\n\t\t\tif (this.content.indexOf(asOrThrows(value, InkObject)) >= 0) {\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tonlyNamed.set(key, value);\n\t\t\t}\n\t\t}\n\n\t\tif (onlyNamed.size > 0) {\n\t\t\tappendIndentation();\n\t\t\tsb.AppendLine('-- named: --');\n\n\t\t\tfor (let [key, value] of onlyNamed){\n\t\t\t\tDebug.AssertType(value, Container, 'Can only print out named Containers');\n\t\t\t\tlet container = value as Container;\n\t\t\t\tcontainer.BuildStringOfHierarchy(sb, indentation, pointedObj);\n\t\t\t\tsb.AppendLine();\n\t\t\t}\n\t\t}\n\n\t\tindentation--;\n\n\t\tappendIndentation();\n\t\tsb.Append(']');\n\t}\n}\n\nexport namespace Container{\n\texport enum CountFlags {\n\t\tVisits = 1,\n\t\tTurns = 2,\n\t\tCountStartOnly = 4,\n\t}\n}\n","import {InkObject} from './Object';\nimport {Container} from './Container';\n\nexport class SearchResult{\n\tpublic obj: InkObject | null = null;\n\tpublic approximate: boolean = false;\n\n\tget correctObj(){\n\t\treturn this.approximate ? null : this.obj;\n\t}\n\n\tget container(){\n\t\treturn (this.obj instanceof Container) ? this.obj : null;\n\t}\n\n\tpublic copy(){\n\t\tlet searchResult = new SearchResult();\n\t\tsearchResult.obj = this.obj;\n\t\tsearchResult.approximate = this.approximate;\n\n\t\treturn searchResult;\n\t}\n}\n","import {InkObject} from './Object';\n\nexport class ControlCommand extends InkObject{\n\n\tprivate _commandType: ControlCommand.CommandType;\n\n\tget commandType(): ControlCommand.CommandType{\n\t\treturn this._commandType;\n\t}\n\n\tconstructor(commandType: ControlCommand.CommandType = ControlCommand.CommandType.NotSet){\n\t\tsuper();\n\t\tthis._commandType = commandType;\n\t}\n\n\tpublic Copy(){\n\t\treturn new ControlCommand(this.commandType);\n\t}\n\tpublic static EvalStart(){\n\t\treturn new ControlCommand(ControlCommand.CommandType.EvalStart);\n\t}\n\tpublic static EvalOutput(){\n\t\treturn new ControlCommand(ControlCommand.CommandType.EvalOutput);\n\t}\n\tpublic static EvalEnd(){\n\t\treturn new ControlCommand(ControlCommand.CommandType.EvalEnd);\n\t}\n\tpublic static Duplicate(){\n\t\treturn new ControlCommand(ControlCommand.CommandType.Duplicate);\n\t}\n\tpublic static PopEvaluatedValue(){\n\t\treturn new ControlCommand(ControlCommand.CommandType.PopEvaluatedValue);\n\t}\n\tpublic static PopFunction(){\n\t\treturn new ControlCommand(ControlCommand.CommandType.PopFunction);\n\t}\n\tpublic static PopTunnel(){\n\t\treturn new ControlCommand(ControlCommand.CommandType.PopTunnel);\n\t}\n\tpublic static BeginString(){\n\t\treturn new ControlCommand(ControlCommand.CommandType.BeginString);\n\t}\n\tpublic static EndString(){\n\t\treturn new ControlCommand(ControlCommand.CommandType.EndString);\n\t}\n\tpublic static NoOp(){\n\t\treturn new ControlCommand(ControlCommand.CommandType.NoOp);\n\t}\n\tpublic static ChoiceCount(){\n\t\treturn new ControlCommand(ControlCommand.CommandType.ChoiceCount);\n\t}\n\tpublic static Turns(){\n\t\treturn new ControlCommand(ControlCommand.CommandType.Turns);\n\t}\n\tpublic static TurnsSince(){\n\t\treturn new ControlCommand(ControlCommand.CommandType.TurnsSince);\n\t}\n\tpublic static ReadCount(){\n\t\treturn new ControlCommand(ControlCommand.CommandType.ReadCount);\n\t}\n\tpublic static Random(){\n\t\treturn new ControlCommand(ControlCommand.CommandType.Random);\n\t}\n\tpublic static SeedRandom(){\n\t\treturn new ControlCommand(ControlCommand.CommandType.SeedRandom);\n\t}\n\tpublic static VisitIndex(){\n\t\treturn new ControlCommand(ControlCommand.CommandType.VisitIndex);\n\t}\n\tpublic static SequenceShuffleIndex(){\n\t\treturn new ControlCommand(ControlCommand.CommandType.SequenceShuffleIndex);\n\t}\n\tpublic static StartThread(){\n\t\treturn new ControlCommand(ControlCommand.CommandType.StartThread);\n\t}\n\tpublic static Done(){\n\t\treturn new ControlCommand(ControlCommand.CommandType.Done);\n\t}\n\tpublic static End(){\n\t\treturn new ControlCommand(ControlCommand.CommandType.End);\n\t}\n\tpublic static ListFromInt(){\n\t\treturn new ControlCommand(ControlCommand.CommandType.ListFromInt);\n\t}\n\tpublic static ListRange(){\n\t\treturn new ControlCommand(ControlCommand.CommandType.ListRange);\n\t}\n\tpublic static ListRandom(){\n\t\treturn new ControlCommand (ControlCommand.CommandType.ListRandom);\n\t}\n\tpublic toString(){\n\t\treturn this.commandType.toString();\n\t}\n}\n\nexport namespace ControlCommand {\n\texport enum CommandType {\n\t\tNotSet = -1,\n\t\tEvalStart,\n\t\tEvalOutput,\n\t\tEvalEnd,\n\t\tDuplicate,\n\t\tPopEvaluatedValue,\n\t\tPopFunction,\n\t\tPopTunnel,\n\t\tBeginString,\n\t\tEndString,\n\t\tNoOp,\n\t\tChoiceCount,\n\t\tTurns,\n\t\tTurnsSince,\n\t\tRandom,\n\t\tSeedRandom,\n\t\tVisitIndex,\n\t\tSequenceShuffleIndex,\n\t\tStartThread,\n\t\tDone,\n\t\tEnd,\n\t\tListFromInt,\n\t\tListRange,\n\t\tListRandom,\n\t\tReadCount,\n\n\t\tTOTAL_VALUES,\n\t}\n}\n","export enum PushPopType {\n\tTunnel = 0,\n\tFunction = 1,\n\tFunctionEvaluationFromGame = 2,\n}\n","import {InkObject} from './Object';\n\nexport class Glue extends InkObject{\n\tpublic toString(){\n\t\treturn 'Glue';\n\t}\n}\n","import {Path} from './Path';\nimport {Container} from './Container';\nimport {InkObject} from './Object';\n\nexport class Pointer{\n  public container: Container | null = null;\n  public index: number = -1;\n\n\tconstructor();\n\tconstructor(container: Container | null, index: number)\n\tconstructor(){\n\t\tif (arguments.length === 2) {\n\t\t\tthis.container = arguments[0];\n\t\t\tthis.index = arguments[1];\n\t\t}\n\t}\n\n\tpublic Resolve(): InkObject | null{\n\t\tif (this.index < 0) return this.container;\n\t\tif (this.container == null) return null;\n\t\tif (this.container.content.length == 0) return this.container;\n\t\tif (this.index >= this.container.content.length) return null;\n\n\t\treturn this.container.content[this.index];\n\t}\n\n\tget isNull(): boolean{\n\t\treturn this.container == null;\n\t}\n\n\tget path(): Path | null{\n\t\tif (this.isNull) return null;\n\n\t\tif (this.index >= 0)\n\t\t\treturn this.container!.path.PathByAppendingComponent(new Path.Component(this.index));\n\t\telse\n\t\t\treturn this.container!.path;\n\t}\n\n\tpublic toString(): string{\n\t\tif (!this.container)\n\t\t\treturn 'Ink Pointer (null)';\n\n\t\treturn 'Ink Pointer -> ' + this.container.path.toString() + ' -- index ' + this.index;\n\t}\n\n\t// This method does not exist in the original C# code, but is here to maintain the\n\t// value semantics of Pointer.\n\tpublic copy(): Pointer{\n\t\treturn new Pointer(this.container, this.index);\n\t}\n\n\tpublic static StartOf(container: Container | null): Pointer{\n\t\treturn new Pointer(container, 0);\n\t}\n\n\tpublic static get Null(): Pointer {\n\t\treturn new Pointer(null, -1);\n\t}\n}\n","import {Path} from './Path';\nimport {PushPopType} from './PushPop';\nimport {StringBuilder} from './StringBuilder';\nimport {InkObject} from './Object';\nimport {Pointer} from './Pointer';\nimport {Container} from './Container';\nimport {throwNullException} from './NullException';\n\nexport class Divert extends InkObject{\n\tget targetPath(){\n\t\tif (this._targetPath != null && this._targetPath.isRelative) {\n\t\t\tlet targetObj = this.targetPointer.Resolve();\n\t\t\tif (targetObj) {\n\t\t\t\tthis._targetPath = targetObj.path;\n\t\t\t}\n\t\t}\n\n\t\treturn this._targetPath;\n\t}\n\tset targetPath(value: Path | null){\n\t\tthis._targetPath = value;\n\t\tthis._targetPointer = Pointer.Null;\n\t}\n\n\tpublic _targetPath: Path | null = null;\n\n\tget targetPointer(){\n\t\tif (this._targetPointer.isNull) {\n\t\t\tlet targetObj = this.ResolvePath(this._targetPath).obj;\n\n\t\t\tif (this._targetPath === null) return throwNullException('this._targetPath');\n\t\t\tif (this._targetPath.lastComponent === null) return throwNullException('this._targetPath.lastComponent');\n\n\t\t\tif (this._targetPath.lastComponent.isIndex) {\n\t\t\t\tif (targetObj === null) return throwNullException('targetObj');\n\t\t\t\tthis._targetPointer.container = (targetObj.parent instanceof Container) ? targetObj.parent : null;\n\t\t\t\tthis._targetPointer.index = this._targetPath.lastComponent.index;\n\t\t\t} else {\n\t\t\t\tthis._targetPointer = Pointer.StartOf((targetObj instanceof Container) ? targetObj : null);\n\t\t\t}\n\t\t}\n\n\t\treturn this._targetPointer.copy();\n\t}\n\n\tpublic _targetPointer: Pointer = Pointer.Null;\n\n\tget targetPathString(){\n\t\tif (this.targetPath == null)\n\t\t\treturn null;\n\n\t\treturn this.CompactPathString(this.targetPath);\n\t}\n\tset targetPathString(value: string | null){\n\t\tif (value == null) {\n\t\t\tthis.targetPath = null;\n\t\t} else {\n\t\t\tthis.targetPath = new Path(value);\n\t\t}\n\t}\n\n\tpublic variableDivertName: string | null = null;\n\tget hasVariableTarget(){\n\t\treturn this.variableDivertName != null;\n\t}\n\n\tpublic pushesToStack: boolean = false;\n\tpublic stackPushType: PushPopType = 0;\n\n\tpublic isExternal: boolean = false;\n\tpublic externalArgs: number = 0;\n\n\tpublic isConditional: boolean = false;\n\n\tconstructor(stackPushType?: PushPopType){\n\t\tsuper();\n\t\tthis.pushesToStack = false;\n\n\t\tif (typeof stackPushType !== 'undefined') {\n\t\t\tthis.pushesToStack = true;\n\t\t\tthis.stackPushType = stackPushType;\n\t\t}\n\t}\n\n\tpublic Equals(obj: Divert | null){\n\t\tlet otherDivert = obj;\n\t\tif (otherDivert instanceof Divert) {\n\t\t\tif (this.hasVariableTarget == otherDivert.hasVariableTarget) {\n\t\t\t\tif (this.hasVariableTarget) {\n\t\t\t\t\treturn this.variableDivertName == otherDivert.variableDivertName;\n\t\t\t\t} else {\n\t\t\t\t\tif (this.targetPath === null) return throwNullException('this.targetPath');\n\t\t\t\t\treturn this.targetPath.Equals(otherDivert.targetPath);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic toString(){\n\t\tif (this.hasVariableTarget) {\n\t\t\treturn 'Divert(variable: ' + this.variableDivertName + ')';\n\t\t}\n\t\telse if (this.targetPath == null) {\n\t\t\treturn 'Divert(null)';\n\t\t} else {\n\n\t\t\tlet sb = new StringBuilder();\n\n\t\t\tlet targetStr = this.targetPath.toString();\n\t\t\t// int? targetLineNum = DebugLineNumberOfPath (targetPath);\n\t\t\tlet targetLineNum = null;\n\t\t\tif (targetLineNum != null) {\n\t\t\t\ttargetStr = 'line ' + targetLineNum;\n\t\t\t}\n\n\t\t\tsb.Append('Divert');\n\n\t\t\tif (this.isConditional)\n\t\t\t\tsb.Append('?');\n\n\t\t\tif (this.pushesToStack) {\n\t\t\t\tif (this.stackPushType == PushPopType.Function) {\n\t\t\t\t\tsb.Append(' function');\n\t\t\t\t} else {\n\t\t\t\t\tsb.Append(' tunnel');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsb.Append(' -> ');\n\t\t\tsb.Append(this.targetPathString);\n\n\t\t\tsb.Append(' (');\n\t\t\tsb.Append(targetStr);\n\t\t\tsb.Append(')');\n\n\t\t\treturn sb.toString();\n\t\t}\n\t}\n}\n","import {InkObject} from './Object';\nimport {Path} from './Path';\nimport {Container} from './Container';\nimport {throwNullException} from './NullException';\n\nexport class ChoicePoint extends InkObject{\n\tpublic _pathOnChoice: Path | null = null;\n\tpublic hasCondition: boolean = false;\n\tpublic hasStartContent: boolean = false;\n\tpublic hasChoiceOnlyContent: boolean = false;\n\tpublic isInvisibleDefault: boolean = false;\n\tpublic onceOnly: boolean = true;\n\n\tconstructor(onceOnly: boolean = true){\n\t\tsuper();\n\t\tthis.onceOnly = onceOnly;\n\t}\n\tget pathOnChoice(): Path | null{\n\t\tif (this._pathOnChoice != null && this._pathOnChoice.isRelative) {\n\t\t\tlet choiceTargetObj = this.choiceTarget;\n\t\t\tif (choiceTargetObj) {\n\t\t\t\tthis._pathOnChoice = choiceTargetObj.path;\n\t\t\t}\n\t\t}\n\t\treturn this._pathOnChoice;\n\t}\n\tset pathOnChoice(value: Path | null){\n\t\tthis._pathOnChoice = value;\n\t}\n\tget choiceTarget(): Container | null{\n\t\tif (this._pathOnChoice === null) return throwNullException('ChoicePoint._pathOnChoice');\n\t\treturn this.ResolvePath(this._pathOnChoice).container;\n\t}\n\tget pathStringOnChoice(): string{\n\t\tif (this.pathOnChoice === null) return throwNullException('ChoicePoint.pathOnChoice');\n\t\treturn this.CompactPathString(this.pathOnChoice);\n\t}\n\tset pathStringOnChoice(value: string){\n\t\tthis.pathOnChoice = new Path(value);\n\t}\n\tget flags(): number{\n\t\tlet flags = 0;\n\t\tif (this.hasCondition)         flags |= 1;\n\t\tif (this.hasStartContent)      flags |= 2;\n\t\tif (this.hasChoiceOnlyContent) flags |= 4;\n\t\tif (this.isInvisibleDefault)   flags |= 8;\n\t\tif (this.onceOnly)             flags |= 16;\n\t\treturn flags;\n\t}\n\tset flags(value: number){\n\t\tthis.hasCondition = (value & 1) > 0;\n\t\tthis.hasStartContent = (value & 2) > 0;\n\t\tthis.hasChoiceOnlyContent = (value & 4) > 0;\n\t\tthis.isInvisibleDefault = (value & 8) > 0;\n\t\tthis.onceOnly = (value & 16) > 0;\n\t}\n\tpublic toString(): string{\n\t\tif (this.pathOnChoice === null) return throwNullException('ChoicePoint.pathOnChoice');\n\t\t// int? targetLineNum = DebugLineNumberOfPath (pathOnChoice);\n\t\tlet targetLineNum = null;\n\t\tlet targetString = this.pathOnChoice.toString();\n\n\t\tif (targetLineNum != null) {\n\t\t\t targetString = ' line ' + targetLineNum + '('+targetString+')';\n\t\t}\n\n\t\treturn 'Choice: -> ' + targetString;\n\t}\n}\n","import {InkObject} from './Object';\nimport {Path} from './Path';\n\nexport class VariableReference extends InkObject{\n\n\tpublic name: string | null;\n\tpublic pathForCount: Path | null = null;\n\n\tget containerForCount(){\n\t\tif (this.pathForCount === null)\n\t\t\treturn null;\n\t\treturn this.ResolvePath(this.pathForCount).container;\n\t}\n\tget pathStringForCount(){\n\t\tif(this.pathForCount === null)\n\t\t\treturn null;\n\n\t\treturn this.CompactPathString(this.pathForCount);\n\t}\n\tset pathStringForCount(value: string | null){\n\t\tif (value === null)\n\t\t\tthis.pathForCount = null;\n\t\telse\n\t\t\tthis.pathForCount = new Path(value);\n\t}\n\n\tconstructor(name: string | null = null){\n\t\tsuper();\n\t\tthis.name = name;\n\t}\n\n\tpublic toString(){\n\t\tif (this.name != null) {\n\t\t\treturn 'var(' + this.name + ')';\n\t\t} else {\n\t\t\tlet pathStr = this.pathStringForCount;\n\t\t\treturn 'read_count(' + pathStr + ')';\n\t\t}\n\t}\n}\n","import {InkObject} from './Object';\n\nexport class VariableAssignment extends InkObject{\n\n\tpublic readonly variableName: string | null;\n\tpublic readonly isNewDeclaration: boolean;\n\tpublic isGlobal: boolean;\n\n\tconstructor(variableName: string | null, isNewDeclaration: boolean){\n\t\tsuper();\n\t\tthis.variableName = variableName || null;\n\t\tthis.isNewDeclaration = !!isNewDeclaration;\n\t\tthis.isGlobal = false;\n\t}\n\n\tpublic toString(): string{\n\t\treturn 'VarAssign to ' + this.variableName;\n\t}\n}\n","import {InkObject} from './Object';\n\nexport class Void extends InkObject{}\n","import {Value, ValueType, IntValue, ListValue} from './Value';\nimport {StoryException} from './StoryException';\nimport {Void} from './Void';\nimport {Path} from './Path';\nimport {InkList, InkListItem} from './InkList';\nimport {InkObject} from './Object';\nimport {asOrNull, asOrThrows} from './TypeAssertion';\nimport {throwNullException} from './NullException';\n\ntype BinaryOp<T> = (left: T, right: T) => any;\ntype UnaryOp<T> = (val: T) => any;\n\nexport class NativeFunctionCall extends InkObject{\n\t// tslint:disable:variable-name\n\tpublic static readonly Add: string \t\t= '+';\n\tpublic static readonly Subtract: string = '-';\n\tpublic static readonly Divide: string   = '/';\n\tpublic static readonly Multiply: string = '*';\n\tpublic static readonly Mod: string      = '%';\n\tpublic static readonly Negate: string   = '_';\n\tpublic static readonly Equal: string    = '==';\n\tpublic static readonly Greater: string  = '>';\n\tpublic static readonly Less: string     = '<';\n\tpublic static readonly GreaterThanOrEquals: string = '>=';\n\tpublic static readonly LessThanOrEquals: string = '<=';\n\tpublic static readonly NotEquals: string   = '!=';\n\tpublic static readonly Not: string      = '!';\n\tpublic static readonly And: string      = '&&';\n\tpublic static readonly Or: string       = '||';\n\tpublic static readonly Min: string      = 'MIN';\n\tpublic static readonly Max: string      = 'MAX';\n\tpublic static readonly Pow: string      = 'POW';\n\tpublic static readonly Floor: string    = 'FLOOR';\n\tpublic static readonly Ceiling: string  = 'CEILING';\n\tpublic static readonly Int: string      = 'INT';\n\tpublic static readonly Float: string    = 'FLOAT';\n\tpublic static readonly Has: string      = '?';\n\tpublic static readonly Hasnt: string    = '!?';\n\tpublic static readonly Intersect: string = '^';\n\tpublic static readonly ListMin: string   = 'LIST_MIN';\n\tpublic static readonly ListMax: string   = 'LIST_MAX';\n\tpublic static readonly All: string       = 'LIST_ALL';\n\tpublic static readonly Count: string     = 'LIST_COUNT';\n\tpublic static readonly ValueOfList: string = 'LIST_VALUE';\n\tpublic static readonly Invert: string    = 'LIST_INVERT';\n\t// tslint:enable:variable-name\n\n\tpublic static CallWithName(functionName: string){\n\t\treturn new NativeFunctionCall(functionName);\n\t}\n\n\tpublic static CallExistsWithName(functionName: string){\n\t\tthis.GenerateNativeFunctionsIfNecessary();\n\t\treturn this._nativeFunctions!.get(functionName);\n\t}\n\n\tget name(){\n\t\tif (this._name === null) return throwNullException('NativeFunctionCall._name');\n\t\treturn this._name;\n\t}\n\tset name(value: string){\n\t\tthis._name = value;\n\t\tif( !this._isPrototype ) {\n\t\t\tif (NativeFunctionCall._nativeFunctions === null) throwNullException('NativeFunctionCall._nativeFunctions');\n\t\t\telse this._prototype = NativeFunctionCall._nativeFunctions.get(this._name) || null;\n\t\t}\n\t}\n\tpublic _name: string | null = null;\n\n\tget numberOfParameters(){\n\t\tif (this._prototype) {\n\t\t\treturn this._prototype.numberOfParameters;\n\t\t} else {\n\t\t\treturn this._numberOfParameters;\n\t\t}\n\t}\n\tset numberOfParameters(value: number){\n\t\tthis._numberOfParameters = value;\n\t}\n\tpublic _numberOfParameters: number = 0;\n\n\tpublic Call(parameters: InkObject[]): InkObject | null{\n\t\tif (this._prototype) {\n\t\t\treturn this._prototype.Call(parameters);\n\t\t}\n\n\t\tif (this.numberOfParameters != parameters.length) {\n\t\t\tthrow new Error('Unexpected number of parameters');\n\t\t}\n\n\t\tlet hasList  = false;\n\t\tfor (let p of parameters) {\n\t\t\tif (p instanceof Void) throw new StoryException('Attempting to perform operation on a void value. Did you forget to \"return\" a value from a function you called here?');\n\t\t\tif (p instanceof ListValue)\n\t\t\t\thasList = true;\n\t\t}\n\n\t\tif (parameters.length == 2 && hasList){\n\t\t\treturn this.CallBinaryListOperation(parameters);\n\t\t}\n\n\t\tlet coercedParams = this.CoerceValuesToSingleType(parameters);\n\t\tlet coercedType = coercedParams[0].valueType;\n\n\t\tif (coercedType == ValueType.Int) {\n\t\t\treturn this.CallType<number>(coercedParams);\n\t\t} else if (coercedType == ValueType.Float) {\n\t\t\treturn this.CallType<number>(coercedParams);\n\t\t} else if (coercedType == ValueType.String) {\n\t\t\treturn this.CallType<string>(coercedParams);\n\t\t} else if (coercedType == ValueType.DivertTarget) {\n\t\t\treturn this.CallType<Path>(coercedParams);\n\t\t} else if (coercedType == ValueType.List) {\n\t\t\treturn this.CallType<InkList>(coercedParams);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tpublic CallType<T>(parametersOfSingleType: Array<Value<T>>){\n\t\tlet param1 = asOrThrows(parametersOfSingleType[0], Value);\n\t\tlet valType = param1.valueType;\n\n\t\tlet val1 = param1 as Value<T>;\n\n\t\tlet paramCount = parametersOfSingleType.length;\n\n\t\tif (paramCount == 2 || paramCount == 1) {\n\t\t\tif (this._operationFuncs === null) return throwNullException('NativeFunctionCall._operationFuncs');\n\t\t\tlet opForTypeObj = this._operationFuncs.get(valType);\n\t\t\tif (!opForTypeObj) {\n\t\t\t\tthrow new StoryException('Cannot perform operation '+this.name+' on '+valType);\n\t\t\t}\n\n\t\t\tif (paramCount == 2) {\n\t\t\t\tlet param2 = asOrThrows(parametersOfSingleType[1], Value);\n\n\t\t\t\tlet val2 = param2 as Value<T>;\n\n\t\t\t\tlet opForType = opForTypeObj as BinaryOp<T>;\n\n\t\t\t\tif (val1.value === null || val2.value === null) return throwNullException('NativeFunctionCall.Call BinaryOp values');\n\t\t\t\tlet resultVal = opForType(val1.value, val2.value);\n\n\t\t\t\treturn Value.Create(resultVal);\n\t\t\t}\n\n\t\t\telse {\n\n\t\t\t\tlet opForType = opForTypeObj as UnaryOp<T>;\n\n\t\t\t\tif (val1.value === null) return throwNullException('NativeFunctionCall.Call UnaryOp value');\n\t\t\t\tlet resultVal = opForType(val1.value);\n\n\t\t\t\treturn Value.Create(resultVal);\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tthrow new Error('Unexpected number of parameters to NativeFunctionCall: ' + parametersOfSingleType.length);\n\t\t}\n\t}\n\n\tpublic CallBinaryListOperation(parameters: InkObject[]){\n\t\tif ((this.name == '+' || this.name == '-') && parameters[0] instanceof ListValue && parameters[1] instanceof IntValue)\n\t\t\treturn this.CallListIncrementOperation(parameters);\n\n\t\tlet v1 = asOrThrows(parameters[0], Value);\n\t\tlet v2 = asOrThrows(parameters[1], Value);\n\n\t\tif ((this.name == '&&' || this.name == '||') && (v1.valueType != ValueType.List || v2.valueType != ValueType.List)) {\n\t\t\tif (this._operationFuncs === null) return throwNullException('NativeFunctionCall._operationFuncs');\n\t\t\tlet op = this._operationFuncs.get(ValueType.Int) as BinaryOp<number>;\n\t\t\tif (op === null) return throwNullException('NativeFunctionCall.CallBinaryListOperation op');\n\t\t\tlet result = op(v1.isTruthy ? 1 : 0, v2.isTruthy ? 1 : 0);\n\t\t\treturn new IntValue(result);\n\t\t}\n\n\t\tif (v1.valueType == ValueType.List && v2.valueType == ValueType.List)\n\t\t\treturn this.CallType<InkList>([v1, v2]);\n\n\t\tthrow new StoryException('Can not call use ' + this.name + ' operation on ' + v1.valueType + ' and ' + v2.valueType);\n\t}\n\n\tpublic CallListIncrementOperation(listIntParams: InkObject[]){\n\t\tlet listVal = asOrThrows(listIntParams[0], ListValue);\n\t\tlet intVal = asOrThrows(listIntParams[1], IntValue);\n\n\t\tlet resultInkList = new InkList();\n\n\t\tif (listVal.value === null) return throwNullException('NativeFunctionCall.CallListIncrementOperation listVal.value');\n\t\tfor (let [listItemKey, listItemValue] of listVal.value) {\n\t\t\tlet listItem = InkListItem.fromSerializedKey(listItemKey);\n\n\t\t\tif (this._operationFuncs === null) return throwNullException('NativeFunctionCall._operationFuncs');\n\t\t\tlet intOp = this._operationFuncs.get(ValueType.Int) as BinaryOp<number>;\n\n\t\t\tif (intVal.value === null) return throwNullException('NativeFunctionCall.CallListIncrementOperation intVal.value');\n\t\t\tlet targetInt = intOp(listItemValue, intVal.value);\n\n\t\t\tlet itemOrigin = null;\n\t\t\tif (listVal.value.origins === null) return throwNullException('NativeFunctionCall.CallListIncrementOperation listVal.value.origins');\n\t\t\tfor (let origin of listVal.value.origins) {\n\t\t\t\tif (origin.name == listItem.originName) {\n\t\t\t\t\titemOrigin = origin;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (itemOrigin != null) {\n\t\t\t\tlet incrementedItem = itemOrigin.TryGetItemWithValue(targetInt, InkListItem.Null);\n\t\t\t\tif (incrementedItem.exists)\n\t\t\t\t\tresultInkList.Add(incrementedItem.result, targetInt);\n\t\t\t}\n\t\t}\n\n\t\treturn new ListValue(resultInkList);\n\t}\n\n\tpublic CoerceValuesToSingleType(parametersIn: InkObject[]){\n\t\tlet valType = ValueType.Int;\n\n\t\tlet specialCaseList: null | ListValue = null;\n\n\t\tfor (let obj of parametersIn) {\n\t\t\tlet val = asOrThrows(obj, Value);\n\t\t\tif (val.valueType > valType) {\n\t\t\t\tvalType = val.valueType;\n\t\t\t}\n\n\t\t\tif (val.valueType == ValueType.List) {\n\t\t\t\t specialCaseList = asOrNull(val, ListValue);\n\t\t\t}\n\t\t}\n\n\t\tlet parametersOut = [];\n\n\t\tif (ValueType[valType] == ValueType[ValueType.List]) {\n\t\t\tfor (let inkObjectVal of parametersIn){\n\t\t\t\tlet val = asOrThrows(inkObjectVal, Value);\n\t\t\t\tif (val.valueType == ValueType.List) {\n\t\t\t\t\tparametersOut.push(val);\n\t\t\t\t} else if (val.valueType == ValueType.Int) {\n\t\t\t\t\tlet intVal = parseInt(val.valueObject);\n\n\t\t\t\t\tspecialCaseList = asOrThrows(specialCaseList, ListValue);\n\t\t\t\t\tif (specialCaseList.value === null) return throwNullException('NativeFunctionCall.CoerceValuesToSingleType specialCaseList.value');\n\t\t\t\t\tlet list = specialCaseList.value.originOfMaxItem;\n\n\t\t\t\t\tif (list === null) return throwNullException('NativeFunctionCall.CoerceValuesToSingleType list');\n\t\t\t\t\tlet item = list.TryGetItemWithValue(intVal, InkListItem.Null);\n\t\t\t\t\tif (item.exists) {\n\t\t\t\t\t\tlet castedValue = new ListValue(item.result, intVal);\n\t\t\t\t\t\tparametersOut.push(castedValue);\n\t\t\t\t\t} else\n\t\t\t\t\t\tthrow new StoryException('Could not find List item with the value ' + intVal + ' in ' + list.name);\n\t\t\t\t} else\n\t\t\t\t\tthrow new StoryException('Cannot mix Lists and ' + val.valueType + ' values in this operation');\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tfor (let inkObjectVal of parametersIn){\n\t\t\t\tlet val = asOrThrows(inkObjectVal, Value);\n\t\t\t\tlet castedValue = val.Cast(valType);\n\t\t\t\tparametersOut.push(castedValue);\n\t\t\t}\n\t\t}\n\n\t\treturn parametersOut;\n\t}\n\n\tconstructor(name: string);\n\tconstructor(name: string, numberOfParameters: number);\n\tconstructor();\n\tconstructor() {\n\t\tsuper();\n\n\t\tif (arguments.length === 0) {\n\t\t\tNativeFunctionCall.GenerateNativeFunctionsIfNecessary();\n\t\t}\n\t\telse if (arguments.length === 1) {\n\t\t\tlet name = arguments[0];\n\t\t\tNativeFunctionCall.GenerateNativeFunctionsIfNecessary();\n\t\t\tthis.name = name;\n\t\t}\n\t\telse if (arguments.length === 2) {\n\t\t\tlet name = arguments[0];\n\t\t\tlet numberOfParameters = arguments[1];\n\n\t\t\tthis._isPrototype = true;\n\t\t\tthis.name = name;\n\t\t\tthis.numberOfParameters = numberOfParameters;\n\t\t}\n\t}\n\n\tpublic static Identity<T>(t: T): any {\n\t\treturn t;\n\t}\n\n\tpublic static GenerateNativeFunctionsIfNecessary(){\n\t\tif (this._nativeFunctions == null) {\n\t\t\tthis._nativeFunctions = new Map();\n\n\t\t\t// Int operations\n\t\t\tthis.AddIntBinaryOp(this.Add,      (x, y) => x + y);\n\t\t\tthis.AddIntBinaryOp(this.Subtract, (x, y) => x - y);\n\t\t\tthis.AddIntBinaryOp(this.Multiply, (x, y) => x * y);\n\t\t\tthis.AddIntBinaryOp(this.Divide,   (x, y) => Math.round(x / y));\n\t\t\tthis.AddIntBinaryOp(this.Mod,      (x, y) => x % y);\n\t\t\tthis.AddIntUnaryOp(this.Negate,   (x) => -x);\n\n\t\t\tthis.AddIntBinaryOp(this.Equal,    (x, y) => x == y ? 1 : 0);\n\t\t\tthis.AddIntBinaryOp(this.Greater,  (x, y) => x > y  ? 1 : 0);\n\t\t\tthis.AddIntBinaryOp(this.Less,     (x, y) => x < y  ? 1 : 0);\n\t\t\tthis.AddIntBinaryOp(this.GreaterThanOrEquals, (x, y) => x >= y ? 1 : 0);\n\t\t\tthis.AddIntBinaryOp(this.LessThanOrEquals, (x, y) => x <= y ? 1 : 0);\n\t\t\tthis.AddIntBinaryOp(this.NotEquals, (x, y) => x != y ? 1 : 0);\n\t\t\tthis.AddIntUnaryOp(this.Not,       (x) => (x == 0) ? 1 : 0);\n\n\t\t\tthis.AddIntBinaryOp(this.And,      (x, y) => x != 0 && y != 0 ? 1 : 0);\n\t\t\tthis.AddIntBinaryOp(this.Or,       (x, y) => x != 0 || y != 0 ? 1 : 0);\n\n\t\t\tthis.AddIntBinaryOp(this.Max,      (x, y) => Math.max(x, y));\n\t\t\tthis.AddIntBinaryOp(this.Min,      (x, y) => Math.min(x, y));\n\n\t\t\tthis.AddIntBinaryOp(this.Pow,      (x, y) => Math.pow(x, y));\n\t\t\tthis.AddIntUnaryOp(this.Floor,     NativeFunctionCall.Identity);\n\t\t\tthis.AddIntUnaryOp(this.Ceiling,   NativeFunctionCall.Identity);\n\t\t\tthis.AddIntUnaryOp(this.Int,       NativeFunctionCall.Identity);\n\t\t\tthis.AddIntUnaryOp(this.Float,     (x) => x);\n\n\t\t\t// Float operations\n\t\t\tthis.AddFloatBinaryOp(this.Add,      (x, y) => x + y);\n\t\t\tthis.AddFloatBinaryOp(this.Subtract, (x, y) => x - y);\n\t\t\tthis.AddFloatBinaryOp(this.Multiply, (x, y) => x * y);\n\t\t\tthis.AddFloatBinaryOp(this.Divide,   (x, y) => x / y);\n\t\t\tthis.AddFloatBinaryOp(this.Mod,      (x, y) => x % y);\n\t\t\tthis.AddFloatUnaryOp(this.Negate,   (x) => -x);\n\n\t\t\tthis.AddFloatBinaryOp(this.Equal,    (x, y) => x == y ? 1 : 0);\n\t\t\tthis.AddFloatBinaryOp(this.Greater,  (x, y) => x > y  ? 1 : 0);\n\t\t\tthis.AddFloatBinaryOp(this.Less,     (x, y) => x < y  ? 1 : 0);\n\t\t\tthis.AddFloatBinaryOp(this.GreaterThanOrEquals, (x, y) => x >= y ? 1 : 0);\n\t\t\tthis.AddFloatBinaryOp(this.LessThanOrEquals, (x, y) => x <= y ? 1 : 0);\n\t\t\tthis.AddFloatBinaryOp(this.NotEquals, (x, y) => x != y ? 1 : 0);\n\t\t\tthis.AddFloatUnaryOp(this.Not,       (x) => (x == 0.0) ? 1 : 0);\n\n\t\t\tthis.AddFloatBinaryOp(this.And,      (x, y) => x != 0.0 && y != 0.0 ? 1 : 0);\n\t\t\tthis.AddFloatBinaryOp(this.Or,       (x, y) => x != 0.0 || y != 0.0 ? 1 : 0);\n\n\t\t\tthis.AddFloatBinaryOp(this.Max,      (x, y) => Math.max(x, y));\n\t\t\tthis.AddFloatBinaryOp(this.Min,      (x, y) => Math.min(x, y));\n\n\t\t\tthis.AddFloatBinaryOp(this.Pow,      (x, y) => Math.pow(x, y));\n\t\t\tthis.AddFloatUnaryOp(this.Floor,     (x) => Math.floor(x));\n\t\t\tthis.AddFloatUnaryOp(this.Ceiling,   (x) => Math.ceil(x));\n\t\t\tthis.AddFloatUnaryOp(this.Int,       (x) => Math.floor(x));\n\t\t\tthis.AddFloatUnaryOp(this.Float,     NativeFunctionCall.Identity);\n\n\t\t\t// String operations\n\t\t\tthis.AddStringBinaryOp(this.Add,     \t(x, y) => x + y); // concat\n\t\t\tthis.AddStringBinaryOp(this.Equal,   \t(x, y) => x === y ? 1 : 0);\n\t\t\tthis.AddStringBinaryOp(this.NotEquals,(x, y) => !(x === y) ? 1 : 0);\n\t\t\tthis.AddStringBinaryOp(this.Has,      (x, y) => x.includes(y) ? 1 : 0);\n\t\t\tthis.AddStringBinaryOp(this.Hasnt,      (x, y) => x.includes(y) ? 0 : 1);\n\n\t\t\tthis.AddListBinaryOp(this.Add, \t\t (x, y) => x.Union(y));\n\t\t\tthis.AddListBinaryOp(this.Subtract,  (x, y) => x.Without(y));\n\t\t\tthis.AddListBinaryOp(this.Has, \t\t (x, y) => x.Contains(y) ? 1 : 0);\n\t\t\tthis.AddListBinaryOp(this.Hasnt, \t (x, y) => x.Contains(y) ? 0 : 1);\n\t\t\tthis.AddListBinaryOp(this.Intersect, (x, y) => x.Intersect(y));\n\n\t\t\tthis.AddListBinaryOp(this.Equal, \t\t\t\t(x, y) => x.Equals(y) ? 1 : 0);\n\t\t\tthis.AddListBinaryOp(this.Greater, \t\t\t\t(x, y) => x.GreaterThan(y) ? 1 : 0);\n\t\t\tthis.AddListBinaryOp(this.Less, \t\t\t\t(x, y) => x.LessThan(y) ? 1 : 0);\n\t\t\tthis.AddListBinaryOp(this.GreaterThanOrEquals, \t(x, y) => x.GreaterThanOrEquals(y) ? 1 : 0);\n\t\t\tthis.AddListBinaryOp(this.LessThanOrEquals, \t(x, y) => x.LessThanOrEquals(y) ? 1 : 0);\n\t\t\tthis.AddListBinaryOp(this.NotEquals, \t\t\t(x, y) => !x.Equals(y) ? 1 : 0);\n\n\t\t\tthis.AddListBinaryOp (this.And, \t\t\t\t(x, y) => x.Count > 0 && y.Count > 0 ? 1 : 0);\n\t\t\tthis.AddListBinaryOp (this.Or,  \t\t\t\t(x, y) => x.Count > 0 || y.Count > 0 ? 1 : 0);\n\n\t\t\tthis.AddListUnaryOp(this.Not, (x) => x.Count == 0 ? 1 : 0);\n\n\t\t\tthis.AddListUnaryOp(this.Invert, (x) => x.inverse);\n\t\t\tthis.AddListUnaryOp(this.All, (x) => x.all);\n\t\t\tthis.AddListUnaryOp(this.ListMin, (x) => x.MinAsList());\n\t\t\tthis.AddListUnaryOp(this.ListMax, (x) => x.MaxAsList());\n\t\t\tthis.AddListUnaryOp(this.Count,  (x) => x.Count);\n\t\t\tthis.AddListUnaryOp(this.ValueOfList,  (x) => x.maxItem.Value);\n\n\t\t\tlet divertTargetsEqual = (d1: Path, d2: Path) => {\n\t\t\t\treturn d1.Equals(d2) ? 1 : 0;\n\t\t\t};\n\t\t\tlet divertTargetsNotEqual = (d1: Path, d2: Path) => {\n\t\t\t\treturn d1.Equals (d2) ? 0 : 1;\n\t\t\t};\n\t\t\tthis.AddOpToNativeFunc(this.Equal, 2, ValueType.DivertTarget, divertTargetsEqual);\n\t\t\tthis.AddOpToNativeFunc(this.NotEquals, 2, ValueType.DivertTarget, divertTargetsNotEqual);\n\t\t}\n\t}\n\n\tpublic AddOpFuncForType(valType: ValueType, op: UnaryOp<number | InkList> | BinaryOp<number | string | InkList | Path>): void{\n\t\tif (this._operationFuncs == null) {\n\t\t\tthis._operationFuncs = new Map();\n\t\t}\n\n\t\tthis._operationFuncs.set(valType, op);\n\t}\n\n\tpublic static AddOpToNativeFunc(name: string, args: number, valType: ValueType, op: UnaryOp<any> | BinaryOp<any>): void{\n\t\tif (this._nativeFunctions === null) return throwNullException('NativeFunctionCall._nativeFunctions');\n\t\tlet nativeFunc = this._nativeFunctions.get(name);\n\t\tif (!nativeFunc) {\n\t\t\tnativeFunc = new NativeFunctionCall(name, args);\n\t\t\tthis._nativeFunctions.set(name, nativeFunc);\n\t\t}\n\n\t\tnativeFunc.AddOpFuncForType(valType, op);\n\t}\n\n\tpublic static AddIntBinaryOp(name: string, op: BinaryOp<number>){\n\t\tthis.AddOpToNativeFunc(name, 2, ValueType.Int, op);\n\t}\n\tpublic static AddIntUnaryOp(name: string, op: UnaryOp<number>){\n\t\tthis.AddOpToNativeFunc(name, 1, ValueType.Int, op);\n\t}\n\n\tpublic static AddFloatBinaryOp(name: string, op: BinaryOp<number>){\n\t\tthis.AddOpToNativeFunc(name, 2, ValueType.Float, op);\n\t}\n\tpublic static AddFloatUnaryOp(name: string, op: UnaryOp<number>){\n\t\tthis.AddOpToNativeFunc(name, 1, ValueType.Float, op);\n\t}\n\n\tpublic static AddStringBinaryOp(name: string, op: BinaryOp<string>){\n\t\tthis.AddOpToNativeFunc(name, 2, ValueType.String, op);\n\t}\n\n\tpublic static AddListBinaryOp(name: string, op: BinaryOp<InkList>){\n\t\tthis.AddOpToNativeFunc(name, 2, ValueType.List, op);\n\t}\n\tpublic static AddListUnaryOp(name: string, op: UnaryOp<InkList>){\n\t\tthis.AddOpToNativeFunc(name, 1, ValueType.List, op);\n\t}\n\n\tpublic toString(){\n\t\treturn 'Native \"' + this.name + '\"';\n\t}\n\n\tpublic _prototype: NativeFunctionCall | null = null;\n\tpublic _isPrototype: boolean = false;\n\tpublic _operationFuncs: Map<ValueType, BinaryOp<any> | UnaryOp<any>> | null = null;\n\tpublic static _nativeFunctions: Map<string, NativeFunctionCall> | null = null;\n\n}\n","import {InkObject} from './Object';\n\nexport class Tag extends InkObject{\n\n\tpublic readonly text: string;\n\n\tconstructor(tagText: string){\n\t\tsuper();\n\t\tthis.text = tagText.toString() || '';\n\t}\n\n\tpublic toString(): string{\n\t\treturn '# ' + this.text;\n\t}\n}\n","import {Path} from './Path';\nimport {CallStack} from './CallStack';\nimport {throwNullException} from './NullException';\nimport {InkObject} from './Object';\n\nexport class Choice extends InkObject{\n\tpublic text: string = '';\n\tpublic index: number = 0;\n\tpublic threadAtGeneration: CallStack.Thread | null = null;\n\tpublic sourcePath: string = '';\n\tpublic targetPath: Path | null = null;\n\tpublic isInvisibleDefault: boolean = false;\n\tpublic originalThreadIndex: number = 0;\n\n\tget pathStringOnChoice(): string{\n\t\tif (this.targetPath === null) return throwNullException('Choice.targetPath');\n\t\treturn this.targetPath.toString();\n\t}\n\tset pathStringOnChoice(value: string){\n\t\tthis.targetPath = new Path(value);\n\t}\n}\n","import {InkList, InkListItem, SerializedInkListItem} from './InkList';\nimport {ListValue} from './Value';\nimport {TryGetResult} from './TryGetResult';\n\nexport class ListDefinition{\n\tpublic _name: string;\n\tpublic _items: Map<SerializedInkListItem, number> | null;\n\tpublic _itemNameToValues: Map<string, number>;\n\n\tconstructor(name: string, items: Map<string, number> | null){\n\t\tthis._name = name || '';\n\t\tthis._items = null;\n\t\tthis._itemNameToValues = items || new Map();\n\t}\n\tget name(){\n\t\treturn this._name;\n\t}\n\tget items(){\n\t\tif (this._items == null){\n\t\t\tthis._items = new Map();\n\t\t\tfor (let [key, value] of this._itemNameToValues){\n\t\t\t\tlet item = new InkListItem(this.name, key);\n\t\t\t\tthis._items.set(item.serialized(), value);\n\t\t\t}\n\t\t}\n\n\t\treturn this._items;\n\t}\n\n\tpublic ValueForItem(item: InkListItem){\n\t\tif (!item.itemName) return 0;\n\n\t\tlet intVal = this._itemNameToValues.get(item.itemName);\n\t\tif (typeof intVal !== 'undefined')\n\t\t\treturn intVal;\n\t\telse\n\t\t\treturn 0;\n\t}\n\tpublic ContainsItem(item: InkListItem){\n\t\tif (!item.itemName) return false;\n\t\tif (item.originName != this.name) return false;\n\n\t\treturn this._itemNameToValues.has(item.itemName);\n\t}\n\tpublic ContainsItemWithName(itemName: string){\n\t\treturn this._itemNameToValues.has(itemName);\n\t}\n\tpublic TryGetItemWithValue(val: number, /* out */ item: InkListItem): TryGetResult<InkListItem>{\n\t\tfor (let [key, value] of this._itemNameToValues){\n\t\t\tif (value == val) {\n\t\t\t\titem = new InkListItem(this.name, key);\n\t\t\t\treturn { result: item, exists: true };\n\t\t\t}\n\t\t}\n\n\t\titem = InkListItem.Null;\n\t\treturn { result: item, exists: false };\n\t}\n\tpublic TryGetValueForItem(item: InkListItem, /* out */ intVal: number): TryGetResult<number>{\n\t\tif (!item.itemName) return { result: 0, exists: false };\n\t\tlet value = this._itemNameToValues.get(item.itemName);\n\n\t\tif (!value) return { result: 0, exists: false };\n\t\treturn { result: value, exists: true };\n\t}\n}\n","import {InkListItem} from './InkList';\nimport {ListValue} from './Value';\nimport {ListDefinition} from './ListDefinition';\nimport {TryGetResult} from './TryGetResult';\nimport {throwNullException} from './NullException';\n\nexport class ListDefinitionsOrigin{\n\tprotected _lists: Map<string, ListDefinition>;\n\tprotected _allUnambiguousListValueCache: Map<string, ListValue>;\n\n\tconstructor(lists: ListDefinition[]){\n\t\tthis._lists = new Map();\n\t\tthis._allUnambiguousListValueCache = new Map();\n\n\t\tfor (let list of lists){\n\t\t\tthis._lists.set(list.name, list);\n\n\t\t\tfor (let [key, val] of list.items){\n\t\t\t\tlet item = InkListItem.fromSerializedKey(key);\n\t\t\t\tlet listValue = new ListValue(item, val);\n\n\t\t\t\tif (!item.itemName) { throw new Error('item.itemName is null or undefined.'); }\n\n\t\t\t\tthis._allUnambiguousListValueCache.set(item.itemName, listValue);\n\t\t\t\tthis._allUnambiguousListValueCache.set(item.fullName, listValue);\n\t\t\t}\n\t\t}\n\t}\n\tget lists(): ListDefinition[]{\n\t\tlet listOfLists: ListDefinition[] = [];\n\n\t\tfor (let [key, value] of this._lists){\n\t\t\tlistOfLists.push(value);\n\t\t}\n\n\t\treturn listOfLists;\n\t}\n\tpublic TryListGetDefinition(name: string | null, /* out */ def: ListDefinition | null): TryGetResult<ListDefinition | null>{\n\t\tif (name === null) { return {result: def, exists: false}; }\n\t\t// initially, this function returns a boolean and the second parameter is an out.\n\t\tlet definition = this._lists.get(name);\n\t\tif (!definition) return { result: def, exists: false };\n\n\t\treturn { result: definition, exists: true };\n\t}\n\tpublic FindSingleItemListWithName(name: string | null){\n\t\tif (name === null) { return throwNullException('name'); }\n\t\tlet val = this._allUnambiguousListValueCache.get(name);\n\n\t\tif (typeof val !== 'undefined'){\n\t\t\treturn val;\n\t\t}\n\n\t\treturn null;\n\t}\n}\n","import {Container} from './Container';\nimport {Value, IntValue, FloatValue, StringValue, DivertTargetValue, VariablePointerValue, ListValue} from './Value';\nimport {Glue} from './Glue';\nimport {ControlCommand} from './ControlCommand';\nimport {PushPopType} from './PushPop';\nimport {Divert} from './Divert';\nimport {ChoicePoint} from './ChoicePoint';\nimport {VariableReference} from './VariableReference';\nimport {VariableAssignment} from './VariableAssignment';\nimport {NativeFunctionCall} from './NativeFunctionCall';\nimport {Void} from './Void';\nimport {Tag} from './Tag';\nimport {Path} from './Path';\nimport {Choice} from './Choice';\nimport {ListDefinition} from './ListDefinition';\nimport {ListDefinitionsOrigin} from './ListDefinitionsOrigin';\nimport {InkListItem, InkList} from './InkList';\nimport {InkObject} from './Object';\nimport {JObject} from './JObject';\nimport {asOrNull, asNumberOrThrows} from './TypeAssertion';\nimport {throwNullException} from './NullException';\n\n// tslint:disable no-conditional-assignment\n\nexport class JsonSerialisation{\n\tpublic static ListToJArray(serialisables: InkObject[]){\n\t\tlet jArray: any[] = [];\n\t\tfor (let s of serialisables) {\n\t\t\tjArray.push(this.RuntimeObjectToJToken(s));\n\t\t}\n\t\treturn jArray;\n\t}\n\n\tpublic static JArrayToRuntimeObjList(jArray: any[], skipLast: boolean = false){\n\t\tlet count = jArray.length;\n\t\tif (skipLast)\n\t\t\tcount--;\n\n\t\tlet list: InkObject[] = [];\n\n\t\tfor (let i = 0; i < count; i++){\n\t\t\tlet jTok = jArray[i];\n\t\t\tlet runtimeObj = this.JTokenToRuntimeObject(jTok);\n\t\t\tif (runtimeObj === null) { return throwNullException('runtimeObj'); }\n\t\t\tlist.push(runtimeObj);\n\t\t}\n\n\t\treturn list;\n\t}\n\n\tpublic static DictionaryRuntimeObjsToJObject(dictionary: Map<string, InkObject>){\n\t\tlet jsonObj: JObject = {};\n\n\t\tfor (let [key, value] of dictionary){\n\t\t\tlet runtimeObj = asOrNull(value, InkObject);\n\t\t\tif (runtimeObj != null)\n\t\t\t\tjsonObj[key] = this.RuntimeObjectToJToken(runtimeObj);\n\t\t}\n\n\t\treturn jsonObj;\n\t}\n\n\tpublic static JObjectToDictionaryRuntimeObjs(jObject: JObject){\n\t\tlet dict: Map<string, InkObject> = new Map();\n\n\t\tfor (let key in jObject){\n\t\t\tif (jObject.hasOwnProperty(key)) {\n\t\t\t\tlet inkObject = this.JTokenToRuntimeObject(jObject[key]);\n\t\t\t\tif (inkObject === null) { return throwNullException('inkObject'); }\n\t\t\t\tdict.set(key, inkObject);\n\t\t\t}\n\t\t}\n\n\t\treturn dict;\n\t}\n\n\tpublic static JObjectToIntDictionary(jObject: JObject){\n\t\tlet dict: Map<string, number> = new Map();\n\t\tfor (let key in jObject){\n\t\t\tif (jObject.hasOwnProperty(key)) {\n\t\t\t\tdict.set(key, parseInt(jObject[key]));\n\t\t\t}\n\t\t}\n\t\treturn dict;\n\t}\n\tpublic static IntDictionaryToJObject(dict: Map<string, number>){\n\t\tlet jObj: JObject = {};\n\t\tfor (let [key, value] of dict){\n\t\t\tjObj[key] = asNumberOrThrows(value);\n\t\t}\n\t\treturn jObj;\n\t}\n\tpublic static JTokenToRuntimeObject(token: any): InkObject | null {\n\t\tif (typeof token === 'number' && !isNaN(token)){\n\t\t\treturn Value.Create(token);\n\t\t}\n\n\t\tif (typeof token === 'string'){\n\t\t\tlet str = token.toString();\n\n\t\t\t// String value\n\t\t\tlet firstChar = str[0];\n\t\t\tif (firstChar == '^')\n\t\t\t\treturn new StringValue(str.substring(1));\n\t\t\telse if(firstChar == '\\n' && str.length == 1)\n\t\t\t\treturn new StringValue('\\n');\n\n\t\t\t// Glue\n\t\t\tif (str == '<>') return new Glue();\n\n\t\t\t// Control commands (would looking up in a hash set be faster?)\n\t\t\tfor (let i = 0; i < JsonSerialisation._controlCommandNames.length; ++i) {\n\t\t\t\tlet cmdName = JsonSerialisation._controlCommandNames[i];\n\t\t\t\tif (str == cmdName) {\n\t\t\t\t\treturn new ControlCommand(i);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Native functions\n\t\t\tif (str == 'L^') str = '^';\n\t\t\tif( NativeFunctionCall.CallExistsWithName(str) )\n\t\t\t\treturn NativeFunctionCall.CallWithName(str);\n\n\t\t\t// Pop\n\t\t\tif (str == '->->')\n\t\t\t\treturn ControlCommand.PopTunnel();\n\t\t\telse if (str == '~ret')\n\t\t\t\treturn ControlCommand.PopFunction();\n\n\t\t\t// Void\n\t\t\tif (str == 'void')\n\t\t\t\treturn new Void ();\n\t\t}\n\n\t\tif (typeof token === 'object' && !Array.isArray(token)){\n\t\t\tlet obj: JObject = token;\n\t\t\tlet propValue;\n\n\t\t\t// Divert target value to path\n\t\t\tif (obj['^->']){\n\t\t\t\tpropValue = obj['^->'];\n\t\t\t\treturn new DivertTargetValue(new Path(propValue.toString()));\n\t\t\t}\n\n\t\t\t// VariablePointerValue\n\t\t\tif (obj['^var']) {\n\t\t\t\tpropValue = obj['^var'];\n\t\t\t\tlet varPtr = new VariablePointerValue(propValue.toString());\n\t\t\t\tif ('ci' in obj){\n\t\t\t\t\tpropValue = obj['ci'];\n\t\t\t\t\tvarPtr.contextIndex = parseInt(propValue);\n\t\t\t\t}\n\t\t\t\treturn varPtr;\n\t\t\t}\n\n\t\t\t// Divert\n\t\t\tlet isDivert = false;\n\t\t\tlet pushesToStack = false;\n\t\t\tlet divPushType = PushPopType.Function;\n\t\t\tlet external = false;\n\t\t\tif (propValue = obj['->']) {\n\t\t\t\tisDivert = true;\n\t\t\t}\n\t\t\telse if (propValue = obj['f()']) {\n\t\t\t\tisDivert = true;\n\t\t\t\tpushesToStack = true;\n\t\t\t\tdivPushType = PushPopType.Function;\n\t\t\t}\n\t\t\telse if (propValue = obj['->t->']) {\n\t\t\t\tisDivert = true;\n\t\t\t\tpushesToStack = true;\n\t\t\t\tdivPushType = PushPopType.Tunnel;\n\t\t\t}\n\t\t\telse if (propValue = obj['x()']) {\n\t\t\t\tisDivert = true;\n\t\t\t\texternal = true;\n\t\t\t\tpushesToStack = false;\n\t\t\t\tdivPushType = PushPopType.Function;\n\t\t\t}\n\n\t\t\tif (isDivert) {\n\t\t\t\tlet divert = new Divert();\n\t\t\t\tdivert.pushesToStack = pushesToStack;\n\t\t\t\tdivert.stackPushType = divPushType;\n\t\t\t\tdivert.isExternal = external;\n\n\t\t\t\tlet target = propValue.toString();\n\n\t\t\t\tif (propValue = obj['var'])\n\t\t\t\t\tdivert.variableDivertName = target;\n\t\t\t\telse\n\t\t\t\t\tdivert.targetPathString = target;\n\n\t\t\t\tdivert.isConditional = !!obj['c'];\n\n\t\t\t\tif (external) {\n\t\t\t\t\tif (propValue = obj['exArgs'])\n\t\t\t\t\t\tdivert.externalArgs = parseInt(propValue);\n\t\t\t\t}\n\n\t\t\t\treturn divert;\n\t\t\t}\n\n\t\t\t// Choice\n\t\t\tif (propValue = obj['*']) {\n\t\t\t\tlet choice = new ChoicePoint();\n\t\t\t\tchoice.pathStringOnChoice = propValue.toString();\n\n\t\t\t\tif (propValue = obj['flg'])\n\t\t\t\t\tchoice.flags = parseInt(propValue);\n\n\t\t\t\treturn choice;\n\t\t\t}\n\n\t\t\t// Variable reference\n\t\t\tif (propValue = obj['VAR?']) {\n\t\t\t\treturn new VariableReference(propValue.toString());\n\t\t\t} else if (propValue = obj['CNT?']) {\n\t\t\t\tlet readCountVarRef = new VariableReference();\n\t\t\t\treadCountVarRef.pathStringForCount = propValue.toString();\n\t\t\t\treturn readCountVarRef;\n\t\t\t}\n\n\t\t\t// Variable assignment\n\t\t\tlet isVarAss = false;\n\t\t\tlet isGlobalVar = false;\n\t\t\tif (propValue = obj['VAR=']) {\n\t\t\t\tisVarAss = true;\n\t\t\t\tisGlobalVar = true;\n\t\t\t} else if (propValue = obj['temp=']) {\n\t\t\t\tisVarAss = true;\n\t\t\t\tisGlobalVar = false;\n\t\t\t}\n\t\t\tif (isVarAss) {\n\t\t\t\tlet varName = propValue.toString();\n\t\t\t\tlet isNewDecl = !obj['re'];\n\t\t\t\tlet varAss = new VariableAssignment(varName, isNewDecl);\n\t\t\t\tvarAss.isGlobal = isGlobalVar;\n\t\t\t\treturn varAss;\n\t\t\t}\n\t\t\tif (obj['#'] !== undefined){\n\t\t\t\tpropValue = obj['#'];\n\t\t\t\treturn new Tag(propValue.toString());\n\t\t\t}\n\n\t\t\t// List value\n\t\t\tif (propValue = obj['list']) {\n\t\t\t\t// var listContent = (Dictionary<string, object>)propValue;\n\t\t\t\tlet listContent: JObject = propValue;\n\t\t\t\tlet rawList = new InkList();\n\t\t\t\tif (propValue = obj['origins']) {\n\t\t\t\t\t// var namesAsObjs = (List<object>)propValue;\n\t\t\t\t\tlet namesAsObjs = propValue as string[];\n\t\t\t\t\t// rawList.SetInitialOriginNames(namesAsObjs.Cast<string>().ToList());\n\t\t\t\t\trawList.SetInitialOriginNames(namesAsObjs);\n\t\t\t\t}\n\n\t\t\t\tfor (let key in listContent){\n\t\t\t\t\tif (listContent.hasOwnProperty(key)) {\n\t\t\t\t\t\tlet nameToVal = listContent[key];\n\t\t\t\t\t\tlet item = new InkListItem(key);\n\t\t\t\t\t\tlet val = parseInt(nameToVal);\n\t\t\t\t\t\trawList.Add(item, val);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn new ListValue(rawList);\n\t\t\t}\n\n\t\t\tif (obj['originalChoicePath'] != null)\n\t\t\t\treturn this.JObjectToChoice(obj);\n\t\t}\n\n\t\t// Array is always a Runtime.Container\n\t\tif (Array.isArray(token)){\n\t\t\treturn this.JArrayToContainer(token);\n\t\t}\n\n\t\tif (token === null || token === undefined)\n\t\t\treturn null;\n\n\t\tthrow new Error('Failed to convert token to runtime object: ' + JSON.stringify(token));\n\t}\n\n\tpublic static RuntimeObjectToJToken(obj: InkObject){\n\t\t// var container = obj as Container;\n\t\tlet container = asOrNull(obj, Container);\n\t\tif (container) {\n\t\t\treturn this.ContainerToJArray(container);\n\t\t}\n\n\t\t// var divert = obj as Divert;\n\t\tlet divert = asOrNull(obj, Divert);\n\t\tif (divert) {\n\t\t\tlet divTypeKey = '->';\n\t\t\tif (divert.isExternal)\n\t\t\t\tdivTypeKey = 'x()';\n\t\t\telse if (divert.pushesToStack) {\n\t\t\t\tif (divert.stackPushType == PushPopType.Function)\n\t\t\t\t\tdivTypeKey = 'f()';\n\t\t\t\telse if (divert.stackPushType == PushPopType.Tunnel)\n\t\t\t\t\tdivTypeKey = '->t->';\n\t\t\t}\n\n\t\t\tlet targetStr;\n\t\t\tif (divert.hasVariableTarget)\n\t\t\t\ttargetStr = divert.variableDivertName;\n\t\t\telse\n\t\t\t\ttargetStr = divert.targetPathString;\n\n\t\t\tlet jObj: JObject = {};\n\t\t\tjObj[divTypeKey] = targetStr;\n\n\t\t\tif (divert.hasVariableTarget)\n\t\t\t\tjObj['var'] = true;\n\n\t\t\tif (divert.isConditional)\n\t\t\t\tjObj['c'] = true;\n\n\t\t\tif (divert.externalArgs > 0)\n\t\t\t\tjObj['exArgs'] = divert.externalArgs;\n\n\t\t\treturn jObj;\n\t\t}\n\n\t\t// var choicePoint = obj as ChoicePoint;\n\t\tlet choicePoint = asOrNull(obj, ChoicePoint);\n\t\tif (choicePoint) {\n\t\t\tlet jObj: JObject = {};\n\t\t\tjObj['*'] = choicePoint.pathStringOnChoice;\n\t\t\tjObj['flg'] = choicePoint.flags;\n\t\t\treturn jObj;\n\t\t}\n\n\t\t// var intVal = obj as IntValue;\n\t\tlet intVal = asOrNull(obj, IntValue);\n\t\tif (intVal)\n\t\t\treturn intVal.value;\n\n\t\t// var floatVal = obj as FloatValue;\n\t\tlet floatVal = asOrNull(obj, FloatValue);\n\t\tif (floatVal)\n\t\t\treturn floatVal.value;\n\n\t\t// var strVal = obj as StringValue;\n\t\tlet strVal = asOrNull(obj, StringValue);\n\t\tif (strVal) {\n\t\t\tif (strVal.isNewline)\n\t\t\t\treturn '\\n';\n\t\t\telse\n\t\t\t\treturn '^' + strVal.value;\n\t\t}\n\n\t\t// var listVal = obj as ListValue;\n\t\tlet listVal = asOrNull(obj, ListValue);\n\t\tif (listVal) {\n\t\t\treturn this.InkListToJObject(listVal);\n\t\t}\n\n\t\t// var divTargetVal = obj as DivertTargetValue;\n\t\tlet divTargetVal = asOrNull(obj, DivertTargetValue);\n\t\tif (divTargetVal) {\n\t\t\tlet divTargetJsonObj: JObject = {};\n\t\t\tif (divTargetVal.value === null) { return throwNullException('divTargetVal.value'); }\n\t\t\tdivTargetJsonObj['^->'] = divTargetVal.value.componentsString;\n\t\t\treturn divTargetJsonObj;\n\t\t}\n\n\t\t// var varPtrVal = obj as VariablePointerValue;\n\t\tlet varPtrVal = asOrNull(obj, VariablePointerValue);\n\t\tif (varPtrVal) {\n\t\t\tlet varPtrJsonObj: JObject = {};\n\t\t\tvarPtrJsonObj['^var'] = varPtrVal.value;\n\t\t\tvarPtrJsonObj['ci'] = varPtrVal.contextIndex;\n\t\t\treturn varPtrJsonObj;\n\t\t}\n\n\t\t// var glue = obj as Runtime.Glue;\n\t\tlet glue = asOrNull(obj, Glue);\n\t\tif (glue) return '<>';\n\n\t\t// var controlCmd = obj as ControlCommand;\n\t\tlet controlCmd = asOrNull(obj, ControlCommand);\n\t\tif (controlCmd) {\n\t\t\treturn JsonSerialisation._controlCommandNames[controlCmd.commandType];\n\t\t}\n\n\t\t// var nativeFunc = obj as Runtime.NativeFunctionCall;\n\t\tlet nativeFunc = asOrNull(obj, NativeFunctionCall);\n\t\tif (nativeFunc) {\n\t\t\tlet name = nativeFunc.name;\n\n\t\t\tif (name == '^') name = 'L^';\n\t\t\treturn name;\n\t\t}\n\n\t\t// Variable reference\n\t\t// var varRef = obj as VariableReference;\n\t\tlet varRef = asOrNull(obj, VariableReference);\n\t\tif (varRef) {\n\t\t\tlet jObj: JObject = {};\n\t\t\tlet readCountPath = varRef.pathStringForCount;\n\t\t\tif (readCountPath != null) {\n\t\t\t\tjObj['CNT?'] = readCountPath;\n\t\t\t} else {\n\t\t\t\tjObj['VAR?'] = varRef.name;\n\t\t\t}\n\n\t\t\treturn jObj;\n\t\t}\n\n\t\t// Variable assignment\n\t\t// var varAss = obj as VariableAssignment;\n\t\tlet varAss = asOrNull(obj, VariableAssignment);\n\t\tif (varAss) {\n\t\t\tlet key = varAss.isGlobal ? 'VAR=' : 'temp=';\n\t\t\tlet jObj: JObject = {};\n\t\t\tjObj[key] = varAss.variableName;\n\n\t\t\t// Reassignment?\n\t\t\tif (!varAss.isNewDeclaration)\n\t\t\t\tjObj['re'] = true;\n\n\t\t\treturn jObj;\n\t\t}\n\n\t\t// var voidObj = obj as Void;\n\t\tlet voidObj = asOrNull(obj, Void);\n\t\tif (voidObj)\n\t\t\treturn 'void';\n\n\t\t// var tag = obj as Tag;\n\t\tlet tag = asOrNull(obj, Tag);\n\t\tif (tag) {\n\t\t\tlet jObj: JObject = {};\n\t\t\tjObj['#'] = tag.text;\n\t\t\treturn jObj;\n\t\t}\n\n\t\t// Used when serialising save state only\n\t\t// var choice = obj as Choice;\n\t\tlet choice = asOrNull(obj, Choice);\n\t\tif (choice)\n\t\t\treturn this.ChoiceToJObject(choice);\n\n\t\tthrow new Error('Failed to convert runtime object to Json token: ' + obj);\n\t}\n\n\tpublic static ContainerToJArray(container: Container){\n\t\tlet jArray = this.ListToJArray(container.content);\n\n\t\tlet namedOnlyContent = container.namedOnlyContent;\n\t\tlet countFlags = container.countFlags;\n\t\tif (namedOnlyContent != null && namedOnlyContent.size > 0 || countFlags > 0 || container.name != null) {\n\n\t\t\tlet terminatingObj;\n\t\t\tif (namedOnlyContent != null) {\n\t\t\t\tterminatingObj = this.DictionaryRuntimeObjsToJObject(namedOnlyContent);\n\n\t\t\t\tfor (let key in terminatingObj){\n\t\t\t\t\tif (terminatingObj.hasOwnProperty(key)) {\n\t\t\t\t\t\t// var subContainerJArray = namedContentObj.Value as JArray;\n\t\t\t\t\t\tlet subContainerJArray = terminatingObj[key];\n\t\t\t\t\t\tif (subContainerJArray != null) {\n\t\t\t\t\t\t\t// var attrJObj = subContainerJArray [subContainerJArray.Count - 1] as JObject;\n\t\t\t\t\t\t\tlet attrJObj = subContainerJArray[subContainerJArray.length - 1] as JObject;\n\t\t\t\t\t\t\tif (attrJObj != null) {\n\t\t\t\t\t\t\t\tdelete attrJObj['#n'];\n\t\t\t\t\t\t\t\tif (Object.keys(attrJObj).length == 0)\n\t\t\t\t\t\t\t\t\tsubContainerJArray[subContainerJArray.length - 1] = null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} else\n\t\t\t\tterminatingObj = {};\n\n\t\t\tif( countFlags > 0 )\n\t\t\t\tterminatingObj['#f'] = countFlags;\n\n\t\t\tif( container.name != null )\n\t\t\t\tterminatingObj['#n'] = container.name;\n\n\t\t\tjArray.push(terminatingObj);\n\t\t}\n\n\t\t// Add null terminator to indicate that there's no dictionary\n\t\telse {\n\t\t\tjArray.push(null);\n\t\t}\n\n\t\treturn jArray;\n\t}\n\n\tpublic static JArrayToContainer(jArray: any[]){\n\t\tlet container = new Container();\n\t\tcontainer.content = this.JArrayToRuntimeObjList(jArray, true);\n\n\t\tlet terminatingObj = jArray[jArray.length - 1] as JObject;\n\t\tif (terminatingObj != null) {\n\n\t\t\tlet namedOnlyContent = new Map();\n\n\t\t\tfor (let key in terminatingObj){\n\t\t\t\tif (key == '#f') {\n\t\t\t\t\tcontainer.countFlags = parseInt(terminatingObj[key]);\n\t\t\t\t} else if (key == '#n') {\n\t\t\t\t\tcontainer.name = terminatingObj[key].toString();\n\t\t\t\t} else {\n\t\t\t\t\tlet namedContentItem = this.JTokenToRuntimeObject(terminatingObj[key]);\n\t\t\t\t\t// var namedSubContainer = namedContentItem as Container;\n\t\t\t\t\tlet namedSubContainer = asOrNull(namedContentItem, Container);\n\t\t\t\t\tif (namedSubContainer)\n\t\t\t\t\t\tnamedSubContainer.name = key;\n\t\t\t\t\tnamedOnlyContent.set(key, namedContentItem);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcontainer.namedOnlyContent = namedOnlyContent;\n\t\t}\n\n\t\treturn container;\n\t}\n\n\tpublic static JObjectToChoice(jObj: JObject){\n\t\tlet choice = new Choice();\n\t\tchoice.text = jObj['text'].toString();\n\t\tchoice.index = parseInt(jObj['index']);\n\t\tchoice.sourcePath = jObj['originalChoicePath'].toString();\n\t\tchoice.originalThreadIndex = parseInt(jObj['originalThreadIndex']);\n\t\tchoice.pathStringOnChoice = jObj['targetPath'].toString();\n\t\treturn choice;\n\t}\n\n\tpublic static ChoiceToJObject(choice: Choice){\n\t\tlet jObj: JObject = {};\n\t\tjObj['text'] = choice.text;\n\t\tjObj['index'] = choice.index;\n\t\tjObj['originalChoicePath'] = choice.sourcePath;\n\t\tjObj['originalThreadIndex'] = choice.originalThreadIndex;\n\t\tjObj['targetPath'] = choice.pathStringOnChoice;\n\t\treturn jObj;\n\t}\n\n\tpublic static InkListToJObject(listVal: ListValue){\n\t\tlet rawList = listVal.value;\n\t\tif (rawList === null) { return throwNullException('rawList'); }\n\n\t\tlet dict: JObject = {};\n\n\t\tlet content: JObject = {};\n\n\t\tfor (let [key, val] of rawList) {\n\t\t\tlet item = InkListItem.fromSerializedKey(key);\n\t\t\tcontent[item.toString()] = val;\n\t\t}\n\n\t\tdict['list'] = content;\n\n\t\tif (rawList.Count == 0 && rawList.originNames != null && rawList.originNames.length > 0) {\n\t\t\t// dict[\"origins\"] = rawList.originNames.Cast<object> ().ToList ();\n\t\t\tdict['origins'] = rawList.originNames;\n\t\t}\n\n\t\treturn dict;\n\t}\n\n\tpublic static ListDefinitionsToJToken(origin: ListDefinitionsOrigin){\n\t\tlet result: JObject = {};\n\n\t\tfor (let def of origin.lists) {\n\t\t\tlet listDefJson: JObject = {};\n\n\t\t\tfor (let [key, val] of def.items) {\n\t\t\t\tlet item = InkListItem.fromSerializedKey(key);\n\t\t\t\tif (item.itemName === null) { return throwNullException('item.itemName'); }\n\t\t\t\tlistDefJson[item.itemName] = val;\n\t\t\t}\n\n\t\t\tresult[def.name] = listDefJson;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tpublic static JTokenToListDefinitions(obj: JObject){\n\t\t// var defsObj = (Dictionary<string, object>)obj;\n\t\tlet defsObj = obj;\n\n\t\tlet allDefs: ListDefinition[] = [];\n\n\t\tfor (let key in defsObj){\n\t\t\tif (defsObj.hasOwnProperty(key)) {\n\t\t\t\tlet name = key.toString();\n\t\t\t\t// var listDefJson = (Dictionary<string, object>)kv.Value;\n\t\t\t\tlet listDefJson: JObject = defsObj[key];\n\n\t\t\t\t// Cast (string, object) to (string, int) for items\n\t\t\t\tlet items: Map<string, number> = new Map();\n\n\t\t\t\tfor (let nameValueKey in listDefJson){\n\t\t\t\t\tif (defsObj.hasOwnProperty(key)) {\n\t\t\t\t\t\tlet nameValue = listDefJson[nameValueKey];\n\t\t\t\t\t\titems.set(nameValueKey, parseInt(nameValue));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlet def = new ListDefinition(name, items);\n\t\t\t\tallDefs.push(def);\n\t\t\t}\n\t\t}\n\n\t\treturn new ListDefinitionsOrigin(allDefs);\n\t}\n\n\tprivate static _controlCommandNames = (() => {\n\t\tlet _controlCommandNames: string[] = [];\n\n\t\t_controlCommandNames[ControlCommand.CommandType.EvalStart] = 'ev';\n\t\t_controlCommandNames[ControlCommand.CommandType.EvalOutput] = 'out';\n\t\t_controlCommandNames[ControlCommand.CommandType.EvalEnd] = '/ev';\n\t\t_controlCommandNames[ControlCommand.CommandType.Duplicate] = 'du';\n\t\t_controlCommandNames[ControlCommand.CommandType.PopEvaluatedValue] = 'pop';\n\t\t_controlCommandNames[ControlCommand.CommandType.PopFunction] = '~ret';\n\t\t_controlCommandNames[ControlCommand.CommandType.PopTunnel] = '->->';\n\t\t_controlCommandNames[ControlCommand.CommandType.BeginString] = 'str';\n\t\t_controlCommandNames[ControlCommand.CommandType.EndString] = '/str';\n\t\t_controlCommandNames[ControlCommand.CommandType.NoOp] = 'nop';\n\t\t_controlCommandNames[ControlCommand.CommandType.ChoiceCount] = 'choiceCnt';\n\t\t_controlCommandNames[ControlCommand.CommandType.Turns] = 'turn';\n\t\t_controlCommandNames[ControlCommand.CommandType.TurnsSince] = 'turns';\n\t\t_controlCommandNames[ControlCommand.CommandType.ReadCount] = 'readc';\n\t\t_controlCommandNames[ControlCommand.CommandType.Random] = 'rnd';\n\t\t_controlCommandNames[ControlCommand.CommandType.SeedRandom] = 'srnd';\n\t\t_controlCommandNames[ControlCommand.CommandType.VisitIndex] = 'visit';\n\t\t_controlCommandNames[ControlCommand.CommandType.SequenceShuffleIndex] = 'seq';\n\t\t_controlCommandNames[ControlCommand.CommandType.StartThread] = 'thread';\n\t\t_controlCommandNames[ControlCommand.CommandType.Done] = 'done';\n\t\t_controlCommandNames[ControlCommand.CommandType.End] = 'end';\n\t\t_controlCommandNames[ControlCommand.CommandType.ListFromInt] = 'listInt';\n\t\t_controlCommandNames[ControlCommand.CommandType.ListRange] = 'range';\n\t\t_controlCommandNames[ControlCommand.CommandType.ListRandom] = 'lrnd';\n\n\t\tfor (let i = 0; i < ControlCommand.CommandType.TOTAL_VALUES; ++i) {\n\t\t\tif (_controlCommandNames[i] == null)\n\t\t\t\tthrow new Error('Control command not accounted for in serialisation');\n\t\t}\n\n\t\treturn _controlCommandNames;\n\t})();\n}\n","import {PushPopType} from './PushPop';\nimport {Path} from './Path';\nimport {Story} from './Story';\nimport {StoryException} from './StoryException';\nimport {JsonSerialisation} from './JsonSerialisation';\nimport {ListValue} from './Value';\nimport {StringBuilder} from './StringBuilder';\nimport {Pointer} from './Pointer';\nimport {InkObject} from './Object';\nimport {Container} from './Container';\nimport {Debug} from './Debug';\nimport {tryGetValueFromMap} from './TryGetResult';\nimport {throwNullException} from './NullException';\n\nexport class CallStack{\n\tget elements(){\n\t\treturn this.callStack;\n\t}\n\n\tget depth(){\n\t\treturn this.elements.length;\n\t}\n\n\tget currentElement(){\n\t\tlet thread = this._threads[this._threads.length - 1];\n\t\tlet cs = thread.callstack;\n\t\treturn cs[cs.length - 1];\n\t}\n\n\tget currentElementIndex(){\n\t\treturn this.callStack.length - 1;\n\t}\n\n\tget currentThread(): CallStack.Thread {\n\t\treturn this._threads[this._threads.length - 1];\n\t}\n\tset currentThread(value: CallStack.Thread){\n\t\tDebug.Assert(this._threads.length == 1, \"Shouldn't be directly setting the current thread when we have a stack of them\");\n\n\t\tthis._threads.length = 0;\n\t\tthis._threads.push(value);\n\t}\n\n\tget canPop(){\n\t\treturn this.callStack.length > 1;\n\t}\n\n\tconstructor(storyContext: Story)\n\tconstructor(toCopy: CallStack)\n\tconstructor(){\n\t\tif (arguments[0] instanceof Story) {\n\t\t\tlet storyContext = arguments[0] as Story;\n\n\t\t\tthis._startOfRoot = Pointer.StartOf(storyContext.rootContentContainer);\n\t\t\tthis.Reset();\n\t\t} else {\n\t\t\tlet toCopy = arguments[0] as CallStack;\n\n\t\t\tthis._threads = [];\n\t\t\tfor (let otherThread of toCopy._threads) {\n\t\t\t\tthis._threads.push(otherThread.Copy());\n\t\t\t}\n\t\t\tthis._startOfRoot = toCopy._startOfRoot;\n\t\t}\n\t}\n\n\tpublic Reset() {\n\t\tthis._threads = [];\n\t\tthis._threads.push(new CallStack.Thread());\n\n\t\tthis._threads[0].callstack.push(new CallStack.Element(PushPopType.Tunnel, this._startOfRoot));\n\t}\n\n\tpublic SetJsonToken(jObject: any, storyContext: Story){\n\t\tthis._threads.length = 0;\n\n\t\t// TODO: (List<object>) jObject [\"threads\"];\n\t\tlet jThreads: any[] = jObject['threads'];\n\n\t\tfor (let jThreadTok of jThreads) {\n\t\t\t// TODO: var jThreadObj = (Dictionary<string, object>)jThreadTok;\n\t\t\tlet jThreadObj = jThreadTok;\n\t\t\tlet thread = new CallStack.Thread(jThreadObj, storyContext);\n\t\t\tthis._threads.push(thread);\n\t\t}\n\n\t\t// TODO: (int)jObject [\"threadCounter\"];\n\t\tthis._threadCounter = parseInt(jObject['threadCounter']);\n\t\tthis._startOfRoot = Pointer.StartOf(storyContext.rootContentContainer);\n\t}\n\tpublic GetJsonToken(){\n\t\tlet jObject: any = {};\n\n\t\tlet jThreads: any[] = [];\n\n\t\tfor (let thread of this._threads) {\n\t\t\tjThreads.push(thread.jsonToken);\n\t\t}\n\n\t\tjObject['threads'] = jThreads;\n\t\tjObject['threadCounter'] = this._threadCounter;\n\n\t\treturn jObject;\n\t}\n\n\tpublic PushThread(){\n\t\tlet newThread = this.currentThread.Copy();\n\t\tthis._threadCounter++;\n\t\tnewThread.threadIndex = this._threadCounter;\n\t\tthis._threads.push(newThread);\n\t}\n\n\tpublic ForkThread(){\n\t\tlet forkedThread = this.currentThread.Copy();\n\t\tthis._threadCounter++;\n\t\tforkedThread.threadIndex = this._threadCounter;\n\t\treturn forkedThread;\n\t}\n\n\tpublic PopThread(){\n\t\tif (this.canPopThread) {\n\t\t\tthis._threads.splice(this._threads.indexOf(this.currentThread), 1);// should be equivalent to a pop()\n\t\t} else {\n\t\t\tthrow new Error(\"Can't pop thread\");\n\t\t}\n\t}\n\n\tget canPopThread(){\n\t\treturn this._threads.length > 1 && !this.elementIsEvaluateFromGame;\n\t}\n\n\tget elementIsEvaluateFromGame(){\n\t\treturn this.currentElement.type == PushPopType.FunctionEvaluationFromGame;\n\t}\n\n\tpublic Push(type: PushPopType, externalEvaluationStackHeight: number = 0, outputStreamLengthWithPushed: number = 0){\n\t\tlet element = new CallStack.Element(\n\t\t\ttype,\n\t\t\tthis.currentElement.currentPointer,\n\t\t\tfalse,\n\t\t);\n\n\t\telement.evaluationStackHeightWhenPushed = externalEvaluationStackHeight;\n\t\telement.functionStartInOutputStream = outputStreamLengthWithPushed;\n\n\t\tthis.callStack.push (element);\n\t}\n\n\tpublic CanPop(type: PushPopType | null = null){\n\t\tif (!this.canPop)\n\t\t\treturn false;\n\n\t\tif (type == null)\n\t\t\treturn true;\n\n\t\treturn this.currentElement.type == type;\n\t}\n\n\tpublic Pop(type: PushPopType | null = null){\n\t\tif (this.CanPop(type)) {\n\t\t\tthis.callStack.pop();\n\t\t\treturn;\n\t\t} else {\n\t\t\tthrow new Error('Mismatched push/pop in Callstack');\n\t\t}\n\t}\n\n\tpublic GetTemporaryVariableWithName(name: string | null, contextIndex: number = -1){\n\n\t\tif (contextIndex == -1)\n\t\t\tcontextIndex = this.currentElementIndex + 1;\n\n\t\tlet contextElement = this.callStack[contextIndex - 1];\n\n\t\tlet varValue = tryGetValueFromMap(contextElement.temporaryVariables, name, null);\n\t\tif (varValue.exists) {\n\t\t\treturn varValue.result;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tpublic SetTemporaryVariable(name: string, value: any, declareNew: boolean, contextIndex: number = -1){\n\n\t\tif (contextIndex == -1)\n\t\t\tcontextIndex = this.currentElementIndex + 1;\n\n\t\tlet contextElement = this.callStack[contextIndex - 1];\n\n\t\tif (!declareNew && !contextElement.temporaryVariables.get(name)) {\n\t\t\tthrow new StoryException('Could not find temporary variable to set: ' + name);\n\t\t}\n\n\t\tlet oldValue = tryGetValueFromMap(contextElement.temporaryVariables, name, null);\n\t\tif (oldValue.exists)\n\t\t\tListValue.RetainListOriginsForAssignment(oldValue.result, value);\n\n\t\tcontextElement.temporaryVariables.set(name, value);\n\t}\n\n\tpublic ContextForVariableNamed(name: string){\n\n\t\tif (this.currentElement.temporaryVariables.get(name)) {\n\t\t\treturn this.currentElementIndex + 1;\n\t\t}\n\n\t\telse {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tpublic ThreadWithIndex(index: number){\n\t\tlet filtered = this._threads.filter((t) => {\n\t\t\tif (t.threadIndex == index) return t;\n\t\t});\n\n\t\treturn filtered[0];\n\t}\n\n\tget callStack(){\n\t\treturn this.currentThread.callstack;\n\t}\n\n\tget callStackTrace(){\n\t\tlet sb = new StringBuilder();\n\n\t\tfor (let t = 0; t < this._threads.length; t++) {\n\t\t\tlet thread = this._threads[t];\n\t\t\tlet isCurrent = (t == this._threads.length - 1);\n\t\t\tsb.AppendFormat('=== THREAD {0}/{1} {2}===\\n', (t+1), this._threads.length, (isCurrent ? '(current) ' : ''));\n\n\t\t\tfor (let i = 0; i < thread.callstack.length; i++) {\n\n\t\t\t\tif (thread.callstack[i].type == PushPopType.Function)\n\t\t\t\t\tsb.Append('  [FUNCTION] ');\n\t\t\t\telse\n\t\t\t\t\tsb.Append('  [TUNNEL] ');\n\n\t\t\t\tlet pointer = thread.callstack[i].currentPointer;\n\t\t\t\tif(!pointer.isNull) {\n\t\t\t\t\tsb.Append('<SOMEWHERE IN ');\n\t\t\t\t\tif (pointer.container === null) { return throwNullException('pointer.container'); }\n\t\t\t\t\tsb.Append(pointer.container.path.toString());\n\t\t\t\t\tsb.AppendLine('>');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn sb.toString();\n\t}\n\n\tpublic _threads!: CallStack.Thread[]; // Banged because it's initialized in Reset().\n\tpublic _threadCounter: number = 0;\n\tpublic _startOfRoot: Pointer = Pointer.Null;\n}\n\nexport namespace CallStack {\n\texport class Element{\n\t\tpublic currentPointer: Pointer;\n\t\tpublic inExpressionEvaluation: boolean;\n\t\tpublic temporaryVariables: Map<string, InkObject>;\n\t\tpublic type: PushPopType;\n\n\t\tpublic evaluationStackHeightWhenPushed: number = 0;\n\t\tpublic functionStartInOutputStream: number = 0;\n\n\t\tconstructor(type: PushPopType, pointer: Pointer, inExpressionEvaluation: boolean = false){\n\t\t\tthis.currentPointer = pointer.copy();\n\t\t\tthis.inExpressionEvaluation = inExpressionEvaluation;\n\t\t\tthis.temporaryVariables = new Map();\n\t\t\tthis.type = type;\n\t\t}\n\n\t\tpublic Copy(){\n\t\t\tlet copy = new Element(this.type, this.currentPointer, this.inExpressionEvaluation);\n\t\t\tcopy.temporaryVariables = new Map(this.temporaryVariables);\n\t\t\tcopy.evaluationStackHeightWhenPushed = this.evaluationStackHeightWhenPushed;\n\t\t\tcopy.functionStartInOutputStream = this.functionStartInOutputStream;\n\t\t\treturn copy;\n\t\t}\n\t}\n\n\texport class Thread{\n\t\tpublic callstack: Element[];\n\t\tpublic threadIndex: number = 0;\n\t\tpublic previousPointer: Pointer = Pointer.Null;\n\n\t\tconstructor();\n\t\tconstructor(jThreadObj: any, storyContext: Story);\n\t\tconstructor(){\n\t\t\tthis.callstack = [];\n\n\t\t\tif (arguments[0] && arguments[1]){\n\t\t\t\tlet jThreadObj = arguments[0];\n\t\t\t\tlet storyContext = arguments[1];\n\n\t\t\t\t// TODO: (int) jThreadObj['threadIndex'] can raise;\n\t\t\t\tthis.threadIndex = parseInt(jThreadObj['threadIndex']);\n\n\t\t\t\tlet jThreadCallstack = jThreadObj['callstack'];\n\n\t\t\t\tfor (let jElTok of jThreadCallstack) {\n\t\t\t\t\tlet jElementObj = jElTok;\n\n\t\t\t\t\t// TODO: (int) jElementObj['type'] can raise;\n\t\t\t\t\tlet pushPopType: PushPopType = parseInt(jElementObj['type']);\n\n\t\t\t\t\tlet pointer = Pointer.Null;\n\n\t\t\t\t\tlet currentContainerPathStr: string;\n\t\t\t\t\t// TODO: jElementObj.TryGetValue (\"cPath\", out currentContainerPathStrToken);\n\t\t\t\t\tlet currentContainerPathStrToken = jElementObj['cPath'];\n\t\t\t\t\tif (typeof currentContainerPathStrToken !== 'undefined') {\n\t\t\t\t\t\tcurrentContainerPathStr = currentContainerPathStrToken.toString();\n\n\t\t\t\t\t\tlet threadPointerResult = storyContext.ContentAtPath(new Path(currentContainerPathStr));\n\t\t\t\t\t\tpointer.container = threadPointerResult.container;\n\t\t\t\t\t\tpointer.index = parseInt(jElementObj['idx']);\n\n\t\t\t\t\t\tif (threadPointerResult.obj == null)\n\t\t\t\t\t\t\tthrow new Error('When loading state, internal story location couldn\\'t be found: ' + currentContainerPathStr + '. Has the story changed since this save data was created?');\n\t\t\t\t\t\telse if (threadPointerResult.approximate) {\n\t\t\t\t\t\t\tif (pointer.container === null) { return throwNullException('pointer.container'); }\n\t\t\t\t\t\t\tstoryContext.Warning(\"When loading state, exact internal story location couldn't be found: '\" + currentContainerPathStr + \"', so it was approximated to '\"+pointer.container.path.toString()+\"' to recover. Has the story changed since this save data was created?\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tlet inExpressionEvaluation = !!jElementObj['exp'];\n\n\t\t\t\t\tlet el = new Element(pushPopType, pointer, inExpressionEvaluation);\n\n\t\t\t\t\tlet jObjTemps = jElementObj['temp'];\n\t\t\t\t\tel.temporaryVariables = JsonSerialisation.JObjectToDictionaryRuntimeObjs(jObjTemps);\n\n\t\t\t\t\tthis.callstack.push(el);\n\t\t\t\t}\n\n\t\t\t\tlet prevContentObjPath = jThreadObj['previousContentObject'];\n\t\t\t\tif(typeof prevContentObjPath !== 'undefined') {\n\t\t\t\t\tlet prevPath = new Path(prevContentObjPath.toString());\n\t\t\t\t\tthis.previousPointer = storyContext.PointerAtPath(prevPath);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic Copy(){\n\t\t\tlet copy = new Thread();\n\t\t\tcopy.threadIndex = this.threadIndex;\n\t\t\tfor (let e of this.callstack) {\n\t\t\t\tcopy.callstack.push(e.Copy());\n\t\t\t}\n\t\t\tcopy.previousPointer = this.previousPointer.copy();\n\t\t\treturn copy;\n\t\t}\n\n\t\tget jsonToken(){\n\t\t\tlet threadJObj: any = {};\n\n\t\t\tlet jThreadCallstack: any[] = [];\n\t\t\tfor (let el of this.callstack) {\n\t\t\t\tlet jObj: any = {};\n\t\t\t\tif (!el.currentPointer.isNull) {\n\t\t\t\t\tif (el.currentPointer.container === null) { return throwNullException('el.currentPointer.container'); }\n\t\t\t\t\tjObj['cPath'] = el.currentPointer.container.path.componentsString;\n\t\t\t\t\tjObj['idx'] = el.currentPointer.index;\n\t\t\t\t}\n\t\t\t\tjObj['exp'] = el.inExpressionEvaluation;\n\t\t\t\tjObj['type'] = el.type;\n\t\t\t\tjObj['temp'] = JsonSerialisation.DictionaryRuntimeObjsToJObject(el.temporaryVariables);\n\t\t\t\tjThreadCallstack.push(jObj);\n\t\t\t}\n\n\t\t\tthreadJObj['callstack'] = jThreadCallstack;\n\t\t\tthreadJObj['threadIndex'] = this.threadIndex;\n\n\t\t\tif (!this.previousPointer.isNull) {\n\t\t\t\tlet resolvedPointer = this.previousPointer.Resolve();\n\t\t\t\tif (resolvedPointer === null) { return throwNullException('this.previousPointer.Resolve()'); }\n\t\t\t\tthreadJObj['previousContentObject'] = resolvedPointer.path.toString();\n\t\t\t}\n\n\t\t\treturn threadJObj;\n\t\t}\n\t}\n}\n","import {Container} from './Container';\nimport {InkObject} from './Object';\nimport {JsonSerialisation} from './JsonSerialisation';\nimport {StoryState} from './StoryState';\nimport {ControlCommand} from './ControlCommand';\nimport {PushPopType} from './PushPop';\nimport {ChoicePoint} from './ChoicePoint';\nimport {Choice} from './Choice';\nimport {Divert} from './Divert';\nimport {Value, StringValue, IntValue, DivertTargetValue, VariablePointerValue, ListValue} from './Value';\nimport {Path} from './Path';\nimport {Void} from './Void';\nimport {Tag} from './Tag';\nimport {VariableAssignment} from './VariableAssignment';\nimport {VariableReference} from './VariableReference';\nimport {NativeFunctionCall} from './NativeFunctionCall';\nimport {StoryException} from './StoryException';\nimport {PRNG} from './PRNG';\nimport {StringBuilder} from './StringBuilder';\nimport {ListDefinitionsOrigin} from './ListDefinitionsOrigin';\nimport {ListDefinition} from './ListDefinition';\nimport {Stopwatch} from './StopWatch';\nimport {Pointer} from './Pointer';\nimport {InkList, InkListItem, KeyValuePair} from './InkList';\nimport {JObject} from './JObject';\nimport {asOrNull, asOrThrows} from './TypeAssertion';\nimport {DebugMetadata} from './DebugMetadata';\nimport {throwNullException} from './NullException';\n\nexport {InkList} from './InkList';\n\n// tslint:disable no-conditional-assignment\n\nif (!Number.isInteger) {\n\tNumber.isInteger = function isInteger(nVal: any) {\n\t\treturn typeof nVal === 'number' && isFinite(nVal) && nVal > -9007199254740992 && nVal < 9007199254740992 && Math.floor(nVal) === nVal;\n\t};\n}\n\nexport class Story extends InkObject{\n\n\tpublic inkVersionCurrent = 19;\n\n\tpublic inkVersionMinimumCompatible = 18;\n\n\tget currentChoices(){\n\t\tlet choices: Choice[] = [];\n\n\t\tif (this._state === null) { return throwNullException('this._state'); }\n\t\tfor(let c of this._state.currentChoices) {\n\t\t\tif (!c.isInvisibleDefault) {\n\t\t\t\tc.index = choices.length;\n\t\t\t\tchoices.push(c);\n\t\t\t}\n\t\t}\n\n\t\treturn choices;\n\t}\n\n\tget currentText(){\n\t\tthis.IfAsyncWeCant(\"call currentText since it's a work in progress\");\n\t\treturn this.state.currentText;\n\t}\n\n\tget currentTags(){\n\t\tthis.IfAsyncWeCant(\"call currentTags since it's a work in progress\");\n\t\treturn this.state.currentTags;\n\t}\n\n\tget currentErrors(){\n\t\treturn this.state.currentErrors;\n\t}\n\n\tget currentWarnings(){\n\t\treturn this.state.currentWarnings;\n\t}\n\n\tget hasError(){\n\t\treturn this.state.hasError;\n\t}\n\n\tget hasWarning(){\n\t\treturn this.state.hasWarning;\n\t}\n\n\tget variablesState(){\n\t\treturn this.state.variablesState;\n\t}\n\n\tget listDefinitions(){\n\t\treturn this._listDefinitions;\n\t}\n\n\tget state(){\n\t\treturn this._state;\n\t}\n\n\t// TODO: Implement Profiler\n\tpublic StartProfiling(){ /* */ }\n\tpublic EndProfiling(){ /* */ }\n\n\tconstructor(contentContainer: Container, lists: ListDefinition[] | null);\n\tconstructor(jsonString: string);\n\tconstructor(json: JObject);\n\tconstructor(){\n\t\tsuper();\n\n\t\t// Discrimination between constructors\n\t\tlet contentContainer: Container;\n\t\tlet lists: ListDefinition[] | null = null;\n\t\tlet json: JObject | null = null;\n\n\t\tif (arguments[0] instanceof Container) {\n\t\t\tcontentContainer = arguments[0] as Container;\n\n\t\t\tif (typeof arguments[1] !== 'undefined') {\n\t\t\t\tlists = arguments[1] as ListDefinition[];\n\t\t\t}\n\n\t\t\t// ------ Story (Container contentContainer, List<Runtime.ListDefinition> lists = null)\n\t\t\tthis._mainContentContainer = contentContainer;\n\t\t\t// ------\n\t\t} else {\n\t\t\tif (typeof arguments[0] === 'string') {\n\t\t\t\tlet jsonString = arguments[0] as string;\n\t\t\t\tjson = JSON.parse(jsonString);\n\t\t\t} else {\n\t\t\t\tjson = arguments[0] as JObject;\n\t\t\t}\n\t\t}\n\n\t\t// ------ Story (Container contentContainer, List<Runtime.ListDefinition> lists = null)\n\t\tif (lists != null)\n\t\t\tthis._listDefinitions = new ListDefinitionsOrigin(lists);\n\n\t\tthis._externals = new Map();\n\t\t// ------\n\n\t\t// ------ Story(string jsonString) : this((Container)null)\n\t\tif (json !== null) {\n\t\t\tlet rootObject: JObject = json;\n\n\t\t\tlet versionObj = rootObject['inkVersion'];\n\t\t\tif (versionObj == null)\n\t\t\t\tthrow new Error(\"ink version number not found. Are you sure it's a valid .ink.json file?\");\n\n\t\t\tlet formatFromFile = parseInt(versionObj);\n\t\t\tif (formatFromFile > this.inkVersionCurrent){\n\t\t\t\tthrow new Error('Version of ink used to build story was newer than the current version of the engine');\n\t\t\t}\n\t\t\telse if (formatFromFile < this.inkVersionMinimumCompatible){\n\t\t\t\tthrow new Error('Version of ink used to build story is too old to be loaded by this version of the engine');\n\t\t\t}\n\t\t\telse if (formatFromFile != this.inkVersionCurrent){\n\t\t\t\tconsole.warn(\"WARNING: Version of ink used to build story doesn't match current version of engine. Non-critical, but recommend synchronising.\");\n\t\t\t}\n\n\t\t\tlet rootToken = rootObject['root'];\n\t\t\tif (rootToken == null)\n\t\t\t\tthrow new Error(\"Root node for ink not found. Are you sure it's a valid .ink.json file?\");\n\n\t\t\tlet listDefsObj;\n\t\t\tif (listDefsObj = rootObject['listDefs']) {\n\t\t\t\tthis._listDefinitions = JsonSerialisation.JTokenToListDefinitions(listDefsObj);\n\t\t\t}\n\n\t\t\tthis._mainContentContainer = asOrThrows(JsonSerialisation.JTokenToRuntimeObject(rootToken), Container);\n\n\t\t\tthis.ResetState();\n\t\t}\n\t\t// ------\n\t}\n\n\tpublic ToJsonString(){\n\t\tlet rootContainerJsonList = JsonSerialisation.RuntimeObjectToJToken(this._mainContentContainer);\n\n\t\tlet  rootObject: JObject = {};\n\t\trootObject['inkVersion'] = this.inkVersionCurrent;\n\t\trootObject['root'] = rootContainerJsonList;\n\n\t\tif (this._listDefinitions != null)\n\t\t\trootObject['listDefs'] = JsonSerialisation.ListDefinitionsToJToken(this._listDefinitions);\n\n\t\treturn JSON.stringify(rootObject);\n\t}\n\n\tpublic ResetState(){\n\t\tthis.IfAsyncWeCant('ResetState');\n\n\t\tthis._state = new StoryState(this);\n\t\tthis._state.variablesState.ObserveVariableChange(this.VariableStateDidChangeEvent.bind(this));\n\n\t\tthis.ResetGlobals();\n\t}\n\n\tpublic ResetErrors(){\n\t\tif (this._state === null) { return throwNullException('this._state'); }\n\t\tthis._state.ResetErrors();\n\t}\n\n\tpublic ResetCallstack(){\n\t\tthis.IfAsyncWeCant('ResetCallstack');\n\t\tif (this._state === null) { return throwNullException('this._state'); }\n\t\tthis._state.ForceEnd();\n\t}\n\n\tpublic ResetGlobals(){\n\t\tif (this._mainContentContainer.namedContent.get('global decl')){\n\t\t\tlet originalPointer = this.state.currentPointer.copy();\n\n\t\t\tthis.ChoosePath(new Path('global decl'), false);\n\n\t\t\tthis.ContinueInternal();\n\n\t\t\tthis.state.currentPointer = originalPointer;\n\t\t}\n\n\t\tthis.state.variablesState.SnapshotDefaultGlobals();\n\t}\n\n\tpublic Continue(){\n\t\tthis.ContinueAsync(0);\n\t\treturn this.currentText;\n\t}\n\n\tget canContinue(){\n\t\treturn this.state.canContinue;\n\t}\n\n\tget asyncContinueComplete(){\n\t\treturn !this._asyncContinueActive;\n\t}\n\n\tpublic ContinueAsync(millisecsLimitAsync: number){\n\t\tif (!this._hasValidatedExternals)\n\t\t\tthis.ValidateExternalBindings();\n\n\t\tthis.ContinueInternal(millisecsLimitAsync);\n\t}\n\n\tpublic ContinueInternal(millisecsLimitAsync = 0){\n\t\tif (this._profiler != null)\n\t\t\tthis._profiler.PreContinue();\n\n\t\tlet isAsyncTimeLimited = millisecsLimitAsync > 0;\n\t\tthis._recursiveContinueCount++;\n\n\t\tif (!this._asyncContinueActive) {\n\t\t\tthis._asyncContinueActive = isAsyncTimeLimited;\n\n\t\t\tif (!this.canContinue) {\n\t\t\t\tthrow new StoryException(\"Can't continue - should check canContinue before calling Continue\");\n\t\t\t}\n\n\t\t\tthis._state.didSafeExit = false;\n\t\t\tthis._state.ResetOutput();\n\n\t\t\tif (this._recursiveContinueCount == 1)\n\t\t\t\tthis._state.variablesState.batchObservingVariableChanges = true;\n\t\t}\n\n\t\tlet durationStopwatch = new Stopwatch();\n\t\tdurationStopwatch.Start();\n\n\t\tlet outputStreamEndsInNewline = false;\n\t\tdo {\n\t\t\ttry {\n\t\t\t\toutputStreamEndsInNewline = this.ContinueSingleStep();\n\t\t\t} catch (e) {\n\t\t\t\tif (!(e instanceof StoryException)) throw e;\n\n\t\t\t\tthis.AddError(e.message, undefined, e.useEndLineNumber);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (outputStreamEndsInNewline)\n\t\t\t\tbreak;\n\n\t\t\tif (this._asyncContinueActive && durationStopwatch.ElapsedMilliseconds > millisecsLimitAsync) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t} while(this.canContinue);\n\n\t\tdurationStopwatch.Stop();\n\n\t\tif (outputStreamEndsInNewline || !this.canContinue) {\n\t\t\tif (this._stateAtLastNewline != null) {\n\t\t\t\tthis.RestoreStateSnapshot(this._stateAtLastNewline);\n\t\t\t\tthis._stateAtLastNewline = null;\n\t\t\t}\n\n\t\t\tif (!this.canContinue) {\n\t\t\t\tif (this.state.callStack.canPopThread)\n\t\t\t\t\tthis.AddError('Thread available to pop, threads should always be flat by the end of evaluation?');\n\n\t\t\t\tif (this.state.generatedChoices.length == 0 && !this.state.didSafeExit && this._temporaryEvaluationContainer == null) {\n\t\t\t\t\tif (this.state.callStack.CanPop(PushPopType.Tunnel))\n\t\t\t\t\t\tthis.AddError (\"unexpectedly reached end of content. Do you need a '->->' to return from a tunnel?\");\n\t\t\t\t\telse if (this.state.callStack.CanPop(PushPopType.Function))\n\t\t\t\t\t\tthis.AddError (\"unexpectedly reached end of content. Do you need a '~ return'?\");\n\t\t\t\t\telse if (!this.state.callStack.canPop)\n\t\t\t\t\t\tthis.AddError (\"ran out of content. Do you need a '-> DONE' or '-> END'?\");\n\t\t\t\t\telse\n\t\t\t\t\t\tthis.AddError ('unexpectedly reached end of content for unknown reason. Please debug compiler!');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.state.didSafeExit = false;\n\n\t\t\tif (this._recursiveContinueCount == 1)\n\t\t\t\tthis._state.variablesState.batchObservingVariableChanges = false;\n\n\t\t\tthis._asyncContinueActive = false;\n\t\t}\n\n\t\tthis._recursiveContinueCount--;\n\n\t\tif (this._profiler != null)\n\t\t\tthis._profiler.PostContinue();\n\t}\n\n\tpublic ContinueSingleStep(){\n\t\tif (this._profiler != null)\n\t\t\tthis._profiler.PreStep();\n\n\t\tthis.Step();\n\n\t\tif (this._profiler != null)\n\t\t\tthis._profiler.PostStep();\n\n\t\tif (!this.canContinue && !this.state.callStack.elementIsEvaluateFromGame) {\n\t\t\tthis.TryFollowDefaultInvisibleChoice();\n\t\t}\n\n\t\tif (this._profiler != null)\n\t\t\tthis._profiler.PreSnapshot();\n\n\t\tif (!this.state.inStringEvaluation) {\n\n\t\t\tif (this._stateAtLastNewline != null) {\n\n\t\t\t\tif (this._stateAtLastNewline.currentTags === null) { return throwNullException('this._stateAtLastNewline.currentTags'); }\n\t\t\t\tif (this.state.currentTags === null) { return throwNullException('this.state.currentTags'); }\n\n\t\t\t\tlet change = this.CalculateNewlineOutputStateChange (\n\t\t\t\t\tthis._stateAtLastNewline.currentText, this.state.currentText,\n\t\t\t\t\tthis._stateAtLastNewline.currentTags.length, this.state.currentTags.length,\n\t\t\t\t);\n\n\t\t\t\tif (change == Story.OutputStateChange.ExtendedBeyondNewline) {\n\n\t\t\t\t\tthis.RestoreStateSnapshot(this._stateAtLastNewline);\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\telse if (change == Story.OutputStateChange.NewlineRemoved) {\n\t\t\t\t\tthis._stateAtLastNewline = null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.state.outputStreamEndsInNewline) {\n\t\t\t\tif (this.canContinue) {\n\t\t\t\t\tif (this._stateAtLastNewline == null)\n\t\t\t\t\t\tthis._stateAtLastNewline = this.StateSnapshot();\n\t\t\t\t}\n\n\t\t\t\telse {\n\t\t\t\t\tthis._stateAtLastNewline = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (this._profiler != null)\n\t\t\tthis._profiler.PostSnapshot();\n\n\t\treturn false;\n\t}\n\n\tpublic CalculateNewlineOutputStateChange(prevText: string | null, currText: string | null, prevTagCount: number, currTagCount: number){\n\t\tif (prevText === null) { return throwNullException('prevText'); }\n\t\tif (currText === null) { return throwNullException('currText'); }\n\n\t\tlet newlineStillExists = currText.length >= prevText.length && currText.charAt(prevText.length - 1) == '\\n';\n\t\tif (prevTagCount == currTagCount && prevText.length == currText.length && newlineStillExists)\n\t\t\treturn Story.OutputStateChange.NoChange;\n\n\t\tif (!newlineStillExists) {\n\t\t\treturn Story.OutputStateChange.NewlineRemoved;\n\t\t}\n\n\t\tif (currTagCount > prevTagCount)\n\t\t\treturn Story.OutputStateChange.ExtendedBeyondNewline;\n\n\t\tfor (let i = prevText.length; i < currText.length; i++) {\n\t\t\tlet c = currText.charAt(i);\n\t\t\tif (c != ' ' && c != '\\t') {\n\t\t\t\treturn Story.OutputStateChange.ExtendedBeyondNewline;\n\t\t\t}\n\t\t}\n\n\t\treturn Story.OutputStateChange.NoChange;\n\t}\n\n\tpublic ContinueMaximally(){\n\t\tthis.IfAsyncWeCant('ContinueMaximally');\n\n\t\tlet sb = new StringBuilder();\n\n\t\twhile (this.canContinue) {\n\t\t\tsb.Append(this.Continue());\n\t\t}\n\n\t\treturn sb.toString();\n\t}\n\n\tpublic ContentAtPath(path: Path){\n\t\treturn this.mainContentContainer.ContentAtPath(path);\n\t}\n\n\tpublic KnotContainerWithName(name: string){\n\t\tlet namedContainer = this.mainContentContainer.namedContent.get(name);\n\t\tif (namedContainer instanceof Container)\n\t\t\treturn namedContainer;\n\t\telse\n\t\t\treturn null;\n\t}\n\n\tpublic PointerAtPath(path: Path) {\n\t\tif (path.length == 0)\n\t\t\treturn Pointer.Null;\n\n\t\tlet p = new Pointer();\n\n\t\tlet pathLengthToUse = path.length;\n\n\t\tlet result = null;\n\t\tif (path.lastComponent === null) { return throwNullException('path.lastComponent'); }\n\n\t\tif (path.lastComponent.isIndex) {\n\t\t\tpathLengthToUse = path.length - 1;\n\t\t\tresult = this.mainContentContainer.ContentAtPath(path, undefined, pathLengthToUse);\n\t\t\tp.container = result.container;\n\t\t\tp.index = path.lastComponent.index;\n\t\t} else {\n\t\t\tresult = this.mainContentContainer.ContentAtPath(path);\n\t\t\tp.container = result.container;\n\t\t\tp.index = -1;\n\t\t}\n\n\t\tif (result.obj == null || result.obj == this.mainContentContainer && pathLengthToUse > 0) {\n\t\t\tthis.Error(\"Failed to find content at path '\" + path + \"', and no approximation of it was possible.\");\n\t\t} else if (result.approximate)\n\t\t\tthis.Warning(\"Failed to find content at path '\" + path + \"', so it was approximated to: '\"+result.obj.path+\"'.\");\n\n\t\treturn p;\n\t}\n\n\tpublic StateSnapshot(){\n\t\treturn this.state.Copy();\n\t}\n\n\tpublic RestoreStateSnapshot(state: StoryState){\n\t\tthis._state = state;\n\t}\n\n\tpublic Step(){\n\n\t\tlet shouldAddToStream = true;\n\n\t\tlet pointer = this.state.currentPointer.copy();\n\t\tif (pointer.isNull) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Container containerToEnter = pointer.Resolve () as Container;\n\t\tlet containerToEnter = asOrNull(pointer.Resolve(), Container);\n\n\t\twhile(containerToEnter) {\n\n\t\t\tthis.VisitContainer(containerToEnter, true);\n\n\t\t\t// No content? the most we can do is step past it\n\t\t\tif (containerToEnter.content.length == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tpointer = Pointer.StartOf(containerToEnter);\n\t\t\t// containerToEnter = pointer.Resolve() as Container;\n\t\t\tcontainerToEnter = asOrNull(pointer.Resolve(), Container);\n\t\t}\n\n\t\tthis.state.currentPointer = pointer.copy();\n\n\t\tif (this._profiler != null)\n\t\t\tthis._profiler.Step(this.state.callStack);\n\n\t\t// Is the current content object:\n\t\t//  - Normal content\n\t\t//  - Or a logic/flow statement - if so, do it\n\t\t// Stop flow if we hit a stack pop when we're unable to pop (e.g. return/done statement in knot\n\t\t// that was diverted to rather than called as a function)\n\t\tlet currentContentObj = pointer.Resolve();\n\t\tlet isLogicOrFlowControl = this.PerformLogicAndFlowControl(currentContentObj);\n\n\t\t// Has flow been forced to end by flow control above?\n\t\tif (this.state.currentPointer.isNull) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (isLogicOrFlowControl) {\n\t\t\tshouldAddToStream = false;\n\t\t}\n\n\t\t// Choice with condition?\n\t\t// var choicePoint = currentContentObj as ChoicePoint;\n\t\tlet choicePoint = asOrNull(currentContentObj, ChoicePoint);\n\t\tif (choicePoint) {\n\t\t\tlet choice = this.ProcessChoice(choicePoint);\n\t\t\tif (choice) {\n\t\t\t\tthis.state.generatedChoices.push(choice);\n\t\t\t}\n\n\t\t\tcurrentContentObj = null;\n\t\t\tshouldAddToStream = false;\n\t\t}\n\n\t\t// If the container has no content, then it will be\n\t\t// the \"content\" itself, but we skip over it.\n\t\tif (currentContentObj instanceof Container) {\n\t\t\tshouldAddToStream = false;\n\t\t}\n\n\t\t// Content to add to evaluation stack or the output stream\n\t\tif (shouldAddToStream) {\n\n\t\t\t// If we're pushing a variable pointer onto the evaluation stack, ensure that it's specific\n\t\t\t// to our current (possibly temporary) context index. And make a copy of the pointer\n\t\t\t// so that we're not editing the original runtime object.\n\t\t\t// var varPointer = currentContentObj as VariablePointerValue;\n\t\t\tlet varPointer = asOrNull(currentContentObj, VariablePointerValue);\n\t\t\tif (varPointer && varPointer.contextIndex == -1) {\n\n\t\t\t\t// Create new object so we're not overwriting the story's own data\n\t\t\t\tlet contextIdx = this.state.callStack.ContextForVariableNamed(varPointer.variableName);\n\t\t\t\tcurrentContentObj = new VariablePointerValue(varPointer.variableName, contextIdx);\n\t\t\t}\n\n\t\t\t// Expression evaluation content\n\t\t\tif (this.state.inExpressionEvaluation) {\n\t\t\t\tthis.state.PushEvaluationStack(currentContentObj);\n\t\t\t}\n\t\t\t// Output stream content (i.e. not expression evaluation)\n\t\t\telse {\n\t\t\t\tthis.state.PushToOutputStream(currentContentObj);\n\t\t\t}\n\t\t}\n\n\t\t// Increment the content pointer, following diverts if necessary\n\t\tthis.NextContent();\n\n\t\t// Starting a thread should be done after the increment to the content pointer,\n\t\t// so that when returning from the thread, it returns to the content after this instruction.\n\t\t// var controlCmd = currentContentObj as ;\n\t\tlet controlCmd = asOrNull(currentContentObj, ControlCommand);\n\t\tif (controlCmd && controlCmd.commandType == ControlCommand.CommandType.StartThread) {\n\t\t\tthis.state.callStack.PushThread();\n\t\t}\n\t}\n\n\tpublic VisitContainer(container: Container, atStart: boolean){\n\t\tif (!container.countingAtStartOnly || atStart) {\n\t\t\tif (container.visitsShouldBeCounted)\n\t\t\t\tthis.IncrementVisitCountForContainer(container);\n\n\t\t\tif (container.turnIndexShouldBeCounted)\n\t\t\t\tthis.RecordTurnIndexVisitToContainer(container);\n\t\t}\n\t}\n\n\tprivate _prevContainers: Container[] = [];\n\tpublic VisitChangedContainersDueToDivert(){\n\t\tlet previousPointer = this.state.previousPointer.copy();\n\t\tlet pointer = this.state.currentPointer.copy();\n\n\t\tif (pointer.isNull || pointer.index == -1)\n\t\t\treturn;\n\n\t\tthis._prevContainers.length = 0;\n\t\tif (!previousPointer.isNull) {\n\t\t\t// Container prevAncestor = previousPointer.Resolve() as Container ?? previousPointer.container as Container;\n\t\t\tlet resolvedPreviousAncestor = previousPointer.Resolve();\n\t\t\tlet prevAncestor = asOrNull(resolvedPreviousAncestor, Container) || asOrNull(previousPointer.container, Container);\n\t\t\twhile (prevAncestor) {\n\t\t\t\tthis._prevContainers.push(prevAncestor);\n\t\t\t\t// prevAncestor = prevAncestor.parent as Container;\n\t\t\t\tprevAncestor = asOrNull(prevAncestor.parent, Container);\n\t\t\t}\n\t\t}\n\n\t\tlet currentChildOfContainer = pointer.Resolve();\n\n\t\tif (currentChildOfContainer == null) return;\n\n\t\t// Container currentContainerAncestor = currentChildOfContainer.parent as Container;\n\t\tlet currentContainerAncestor = asOrNull(currentChildOfContainer.parent, Container);\n\t\twhile (currentContainerAncestor && (this._prevContainers.indexOf(currentContainerAncestor) < 0 || currentContainerAncestor.countingAtStartOnly)) {\n\n\t\t\t// Check whether this ancestor container is being entered at the start,\n\t\t\t// by checking whether the child object is the first.\n\t\t\tlet enteringAtStart = currentContainerAncestor.content.length > 0\n\t\t\t\t&& currentChildOfContainer == currentContainerAncestor.content[0];\n\n\t\t\t// Mark a visit to this container\n\t\t\tthis.VisitContainer(currentContainerAncestor, enteringAtStart);\n\n\t\t\tcurrentChildOfContainer = currentContainerAncestor;\n\t\t\t// currentContainerAncestor = currentContainerAncestor.parent as Container;\n\t\t\tcurrentContainerAncestor = asOrNull(currentContainerAncestor.parent, Container);\n\t\t}\n\t}\n\n\tpublic ProcessChoice(choicePoint: ChoicePoint){\n\t\tlet showChoice = true;\n\n\t\t// Don't create choice if choice point doesn't pass conditional\n\t\tif (choicePoint.hasCondition) {\n\t\t\tlet conditionValue = this.state.PopEvaluationStack();\n\t\t\tif (!this.IsTruthy(conditionValue)) {\n\t\t\t\tshowChoice = false;\n\t\t\t}\n\t\t}\n\n\t\tlet startText = '';\n\t\tlet choiceOnlyText = '';\n\n\t\tif (choicePoint.hasChoiceOnlyContent) {\n\t\t\t// var choiceOnlyStrVal = state.PopEvaluationStack () as StringValue;\n\t\t\tlet choiceOnlyStrVal = asOrThrows(this.state.PopEvaluationStack(), StringValue);\n\t\t\tchoiceOnlyText = choiceOnlyStrVal.value || '';\n\t\t}\n\n\t\tif (choicePoint.hasStartContent) {\n\t\t\t// var startStrVal = state.PopEvaluationStack () as StringValue;\n\t\t\tlet startStrVal = asOrThrows(this.state.PopEvaluationStack(), StringValue);\n\t\t\tstartText = startStrVal.value || '';\n\t\t}\n\n\t\t// Don't create choice if player has already read this content\n\t\tif (choicePoint.onceOnly) {\n\t\t\tlet visitCount = this.VisitCountForContainer(choicePoint.choiceTarget);\n\t\t\tif (visitCount > 0) {\n\t\t\t\tshowChoice = false;\n\t\t\t}\n\t\t}\n\n\t\t// We go through the full process of creating the choice above so\n\t\t// that we consume the content for it, since otherwise it'll\n\t\t// be shown on the output stream.\n\t\tif (!showChoice) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet choice = new Choice();\n\t\tchoice.targetPath = choicePoint.pathOnChoice;\n\t\tchoice.sourcePath = choicePoint.path.toString();\n\t\tchoice.isInvisibleDefault = choicePoint.isInvisibleDefault;\n\t\tchoice.threadAtGeneration = this.state.callStack.ForkThread();\n\n\t\tchoice.text = (startText + choiceOnlyText).replace(/^[ \\t]+|[ \\t]+$/g, '');\n\n\t\treturn choice;\n\t}\n\n\tpublic IsTruthy(obj: InkObject){\n\t\tlet truthy = false;\n\t\tif (obj instanceof Value) {\n\t\t\tlet val = obj;\n\n\t\t\tif (val instanceof DivertTargetValue) {\n\t\t\t\tlet divTarget = val;\n\t\t\t\tthis.Error(\"Shouldn't use a divert target (to \" + divTarget.targetPath + \") as a conditional value. Did you intend a function call 'likeThis()' or a read count check 'likeThis'? (no arrows)\");\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn val.isTruthy;\n\t\t}\n\t\treturn truthy;\n\t}\n\n\tpublic PerformLogicAndFlowControl(contentObj: InkObject | null){\n\t\tif( contentObj == null ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Divert\n\t\tif (contentObj instanceof Divert) {\n\t\t\tlet currentDivert = contentObj;\n\n\t\t\tif (currentDivert.isConditional) {\n\t\t\t\tlet conditionValue = this.state.PopEvaluationStack();\n\n\t\t\t\t// False conditional? Cancel divert\n\t\t\t\tif (!this.IsTruthy(conditionValue))\n\t\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (currentDivert.hasVariableTarget) {\n\t\t\t\tlet varName = currentDivert.variableDivertName;\n\n\t\t\t\tlet varContents = this.state.variablesState.GetVariableWithName(varName);\n\n\t\t\t\tif (varContents == null) {\n\t\t\t\t\tthis.Error('Tried to divert using a target from a variable that could not be found (' + varName + ')');\n\t\t\t\t}\n\t\t\t\telse if (!(varContents instanceof DivertTargetValue)) {\n\n\t\t\t\t\t// var intContent = varContents as IntValue;\n\t\t\t\t\tlet intContent = asOrNull(varContents, IntValue);\n\n\t\t\t\t\tlet errorMessage = 'Tried to divert to a target from a variable, but the variable (' + varName + \") didn't contain a divert target, it \";\n\t\t\t\t\tif (intContent instanceof IntValue && intContent.value == 0) {\n\t\t\t\t\t\terrorMessage += 'was empty/null (the value 0).';\n\t\t\t\t\t} else {\n\t\t\t\t\t\terrorMessage += \"contained '\" + varContents + \"'.\";\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.Error(errorMessage);\n\t\t\t\t}\n\n\t\t\t\tlet target = asOrThrows(varContents, DivertTargetValue);\n\t\t\t\tthis.state.divertedPointer = this.PointerAtPath(target.targetPath);\n\n\t\t\t} else if (currentDivert.isExternal) {\n\t\t\t\tthis.CallExternalFunction(currentDivert.targetPathString, currentDivert.externalArgs);\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tthis.state.divertedPointer = currentDivert.targetPointer.copy();\n\t\t\t}\n\n\t\t\tif (currentDivert.pushesToStack) {\n\t\t\t\tthis.state.callStack.Push(\n\t\t\t\t\tcurrentDivert.stackPushType,\n\t\t\t\t\tundefined,\n\t\t\t\t\tthis.state.outputStream.length,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (this.state.divertedPointer.isNull && !currentDivert.isExternal) {\n\n\t\t\t\tif (currentDivert && currentDivert.debugMetadata && currentDivert.debugMetadata.sourceName != null) {\n\t\t\t\t\tthis.Error(\"Divert target doesn't exist: \" + currentDivert.debugMetadata.sourceName);\n\t\t\t\t} else {\n\t\t\t\t\tthis.Error('Divert resolution failed: ' + currentDivert);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\t// Start/end an expression evaluation? Or print out the result?\n\t\telse if( contentObj instanceof ControlCommand ) {\n\t\t\tlet evalCommand = contentObj;\n\n\t\t\tswitch (evalCommand.commandType) {\n\n\t\t\tcase ControlCommand.CommandType.EvalStart:\n\t\t\t\tthis.Assert(this.state.inExpressionEvaluation === false, 'Already in expression evaluation?');\n\t\t\t\tthis.state.inExpressionEvaluation = true;\n\t\t\t\tbreak;\n\n\t\t\tcase ControlCommand.CommandType.EvalEnd:\n\t\t\t\tthis.Assert(this.state.inExpressionEvaluation === true, 'Not in expression evaluation mode');\n\t\t\t\tthis.state.inExpressionEvaluation = false;\n\t\t\t\tbreak;\n\n\t\t\tcase ControlCommand.CommandType.EvalOutput:\n\n\t\t\t\t// If the expression turned out to be empty, there may not be anything on the stack\n\t\t\t\tif (this.state.evaluationStack.length > 0) {\n\n\t\t\t\t\tlet output = this.state.PopEvaluationStack();\n\n\t\t\t\t\t// Functions may evaluate to Void, in which case we skip output\n\t\t\t\t\tif (!(output instanceof Void)) {\n\t\t\t\t\t\t// TODO: Should we really always blanket convert to string?\n\t\t\t\t\t\t// It would be okay to have numbers in the output stream the\n\t\t\t\t\t\t// only problem is when exporting text for viewing, it skips over numbers etc.\n\t\t\t\t\t\tlet text = new StringValue(output.toString());\n\n\t\t\t\t\t\tthis.state.PushToOutputStream(text);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase ControlCommand.CommandType.NoOp:\n\t\t\t\tbreak;\n\n\t\t\tcase ControlCommand.CommandType.Duplicate:\n\t\t\t\tthis.state.PushEvaluationStack(this.state.PeekEvaluationStack());\n\t\t\t\tbreak;\n\n\t\t\tcase ControlCommand.CommandType.PopEvaluatedValue:\n\t\t\t\tthis.state.PopEvaluationStack();\n\t\t\t\tbreak;\n\n\t\t\tcase ControlCommand.CommandType.PopFunction:\n\t\t\tcase ControlCommand.CommandType.PopTunnel:\n\n\t\t\t\tlet popType = evalCommand.commandType == ControlCommand.CommandType.PopFunction ?\n\t\t\t\t\tPushPopType.Function : PushPopType.Tunnel;\n\n\t\t\t\tlet overrideTunnelReturnTarget: DivertTargetValue | null = null;\n\t\t\t\tif (popType == PushPopType.Tunnel) {\n\t\t\t\t\tlet popped = this.state.PopEvaluationStack();\n\t\t\t\t\t// overrideTunnelReturnTarget = popped as DivertTargetValue;\n\t\t\t\t\toverrideTunnelReturnTarget = asOrNull(popped, DivertTargetValue);\n\t\t\t\t\tif (overrideTunnelReturnTarget === null) {\n\t\t\t\t\t\tthis.Assert(popped instanceof Void, \"Expected void if ->-> doesn't override target\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (this.state.TryExitFunctionEvaluationFromGame()){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (this.state.callStack.currentElement.type != popType || !this.state.callStack.canPop) {\n\n\t\t\t\t\tlet names: Map<PushPopType, string> = new Map();\n\t\t\t\t\tnames.set(PushPopType.Function, 'function return statement (~ return)');\n\t\t\t\t\tnames.set(PushPopType.Tunnel, 'tunnel onwards statement (->->)');\n\n\t\t\t\t\tlet expected = names.get(this.state.callStack.currentElement.type);\n\t\t\t\t\tif (!this.state.callStack.canPop) {\n\t\t\t\t\t\texpected = 'end of flow (-> END or choice)';\n\t\t\t\t\t}\n\n\t\t\t\t\tlet errorMsg = 'Found ' + names.get(popType) + ', when expected ' + expected;\n\n\t\t\t\t\tthis.Error(errorMsg);\n\t\t\t\t}\n\n\t\t\t\telse {\n\t\t\t\t\tthis.state.PopCallStack();\n\n\t\t\t\t\tif (overrideTunnelReturnTarget)\n\t\t\t\t\t\tthis.state.divertedPointer = this.PointerAtPath(overrideTunnelReturnTarget.targetPath);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase ControlCommand.CommandType.BeginString:\n\t\t\t\tthis.state.PushToOutputStream(evalCommand);\n\n\t\t\t\tthis.Assert(this.state.inExpressionEvaluation === true, 'Expected to be in an expression when evaluating a string');\n\t\t\t\tthis.state.inExpressionEvaluation = false;\n\t\t\t\tbreak;\n\n\t\t\tcase ControlCommand.CommandType.EndString:\n\n\t\t\t\tlet contentStackForString: InkObject[] = [];\n\n\t\t\t\tlet outputCountConsumed = 0;\n\t\t\t\tfor (let i = this.state.outputStream.length - 1; i >= 0; --i) {\n\t\t\t\t\tlet obj = this.state.outputStream[i];\n\n\t\t\t\t\toutputCountConsumed++;\n\n\t\t\t\t\t// var command = obj as ControlCommand;\n\t\t\t\t\tlet command = asOrNull(obj, ControlCommand);\n\t\t\t\t\tif (command && command.commandType == ControlCommand.CommandType.BeginString) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif( obj instanceof StringValue ) {\n\t\t\t\t\t\tcontentStackForString.push(obj);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Consume the content that was produced for this string\n\t\t\t\tthis.state.PopFromOutputStream(outputCountConsumed);\n\n\t\t\t\t// The C# version uses a Stack for contentStackForString, but we're\n\t\t\t\t// using a simple array, so we need to reverse it before using it\n\t\t\t\tcontentStackForString = contentStackForString.reverse();\n\n\t\t\t\t// Build string out of the content we collected\n\t\t\t\tlet sb = new StringBuilder();\n\t\t\t\tfor (let c of contentStackForString) {\n\t\t\t\t\tsb.Append(c.toString());\n\t\t\t\t}\n\n\t\t\t\t// Return to expression evaluation (from content mode)\n\t\t\t\tthis.state.inExpressionEvaluation = true;\n\t\t\t\tthis.state.PushEvaluationStack(new StringValue(sb.toString()));\n\t\t\t\tbreak;\n\n\t\t\tcase ControlCommand.CommandType.ChoiceCount:\n\t\t\t\tlet choiceCount = this.state.generatedChoices.length;\n\t\t\t\tthis.state.PushEvaluationStack(new IntValue(choiceCount));\n\t\t\t\tbreak;\n\n\t\t\tcase ControlCommand.CommandType.Turns:\n\t\t\t\tthis.state.PushEvaluationStack (new IntValue (this.state.currentTurnIndex+1));\n\t\t\t\tbreak;\n\n\t\t\tcase ControlCommand.CommandType.TurnsSince:\n\t\t\tcase ControlCommand.CommandType.ReadCount:\n\t\t\t\tlet target = this.state.PopEvaluationStack();\n\t\t\t\tif( !(target instanceof DivertTargetValue) ) {\n\t\t\t\t\tlet extraNote = '';\n\t\t\t\t\tif( target instanceof IntValue )\n\t\t\t\t\t\textraNote = \". Did you accidentally pass a read count ('knot_name') instead of a target ('-> knot_name')?\";\n\t\t\t\t\tthis.Error('TURNS_SINCE / READ_COUNT expected a divert target (knot, stitch, label name), but saw '+target+extraNote);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// var divertTarget = target as DivertTargetValue;\n\t\t\t\tlet divertTarget = asOrThrows(target, DivertTargetValue);\n\t\t\t\t// var container = ContentAtPath (divertTarget.targetPath).correctObj as Container;\n\t\t\t\tlet container = asOrNull(this.ContentAtPath(divertTarget.targetPath).correctObj, Container);\n\n\t\t\t\tlet eitherCount;\n\t\t\t\tif (container != null) {\n\t\t\t\t\tif (evalCommand.commandType == ControlCommand.CommandType.TurnsSince)\n\t\t\t\t\t\teitherCount = this.TurnsSinceForContainer(container);\n\t\t\t\t\telse\n\t\t\t\t\t\teitherCount = this.VisitCountForContainer(container);\n\t\t\t\t} else {\n\t\t\t\t\tif (evalCommand.commandType == ControlCommand.CommandType.TurnsSince)\n\t\t\t\t\t\teitherCount = -1;\n\t\t\t\t\telse\n\t\t\t\t\t\teitherCount = 0;\n\n\t\t\t\t\tthis.Warning('Failed to find container for ' + evalCommand.toString() + ' lookup at ' + divertTarget.targetPath.toString());\n\t\t\t\t}\n\n\t\t\t\tthis.state.PushEvaluationStack(new IntValue(eitherCount));\n\t\t\t\tbreak;\n\n\t\t\tcase ControlCommand.CommandType.Random: {\n\t\t\t\tlet maxInt = asOrNull(this.state.PopEvaluationStack(), IntValue);\n\t\t\t\tlet minInt = asOrNull(this.state.PopEvaluationStack(), IntValue);\n\n\t\t\t\tif (minInt == null || minInt instanceof IntValue === false)\n\t\t\t\t\treturn this.Error('Invalid value for minimum parameter of RANDOM(min, max)');\n\n\t\t\t\tif (maxInt == null || minInt instanceof IntValue === false)\n\t\t\t\t\treturn this.Error('Invalid value for maximum parameter of RANDOM(min, max)');\n\n\t\t\t\t// Originally a primitive type, but here, can be null.\n\t\t\t\t// TODO: Replace by default value?\n\t\t\t\tif (maxInt.value === null) { return throwNullException('maxInt.value'); }\n\t\t\t\tif (minInt.value === null) { return throwNullException('minInt.value'); }\n\n\t\t\t\tlet randomRange = maxInt.value - minInt.value + 1;\n\t\t\t\tif (randomRange <= 0)\n\t\t\t\t\tthis.Error('RANDOM was called with minimum as ' + minInt.value + ' and maximum as ' + maxInt.value + '. The maximum must be larger');\n\n\t\t\t\tlet resultSeed = this.state.storySeed + this.state.previousRandom;\n\t\t\t\tlet random = new PRNG(resultSeed);\n\n\t\t\t\tlet nextRandom = random.next();\n\t\t\t\tlet chosenValue = (nextRandom % randomRange) + minInt.value;\n\t\t\t\tthis.state.PushEvaluationStack(new IntValue(chosenValue));\n\n\t\t\t\t// Next random number (rather than keeping the Random object around)\n\t\t\t\tthis.state.previousRandom = nextRandom;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase ControlCommand.CommandType.SeedRandom:\n\t\t\t\tlet seed = asOrNull(this.state.PopEvaluationStack(), IntValue);\n\t\t\t\tif (seed == null || seed instanceof IntValue === false)\n\t\t\t\t\treturn this.Error('Invalid value passed to SEED_RANDOM');\n\n\t\t\t\t// Originally a primitive type, but here, can be null.\n\t\t\t\t// TODO: Replace by default value?\n\t\t\t\tif (seed.value === null) { return throwNullException('minInt.value'); }\n\n\t\t\t\tthis.state.storySeed = seed.value;\n\t\t\t\tthis.state.previousRandom = 0;\n\n\t\t\t\tthis.state.PushEvaluationStack(new Void());\n\t\t\t\tbreak;\n\n\t\t\tcase ControlCommand.CommandType.VisitIndex:\n\t\t\t\tlet count = this.VisitCountForContainer(this.state.currentPointer.container) - 1; // index not count\n\t\t\t\tthis.state.PushEvaluationStack(new IntValue(count));\n\t\t\t\tbreak;\n\n\t\t\tcase ControlCommand.CommandType.SequenceShuffleIndex:\n\t\t\t\tlet shuffleIndex = this.NextSequenceShuffleIndex();\n\t\t\t\tthis.state.PushEvaluationStack(new IntValue(shuffleIndex));\n\t\t\t\tbreak;\n\n\t\t\tcase ControlCommand.CommandType.StartThread:\n\t\t\t\t// Handled in main step function\n\t\t\t\tbreak;\n\n\t\t\tcase ControlCommand.CommandType.Done:\n\t\t\t\t// We may exist in the context of the initial\n\t\t\t\t// act of creating the thread, or in the context of\n\t\t\t\t// evaluating the content.\n\t\t\t\tif (this.state.callStack.canPopThread) {\n\t\t\t\t\tthis.state.callStack.PopThread();\n\t\t\t\t}\n\n\t\t\t\t// In normal flow - allow safe exit without warning\n\t\t\t\telse {\n\t\t\t\t\tthis.state.didSafeExit = true;\n\n\t\t\t\t\t// Stop flow in current thread\n\t\t\t\t\tthis.state.currentPointer = Pointer.Null;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\t// Force flow to end completely\n\t\t\tcase ControlCommand.CommandType.End:\n\t\t\t\tthis.state.ForceEnd();\n\t\t\t\tbreak;\n\n\t\t\tcase ControlCommand.CommandType.ListFromInt:\n\t\t\t\t// var intVal = state.PopEvaluationStack () as IntValue;\n\t\t\t\tlet intVal = asOrNull(this.state.PopEvaluationStack(), IntValue);\n\t\t\t\t// var listNameVal = state.PopEvaluationStack () as StringValue;\n\t\t\t\tlet listNameVal = asOrThrows(this.state.PopEvaluationStack(), StringValue);\n\n\t\t\t\tif (intVal === null) {\n\t\t\t\t\tthrow new StoryException('Passed non-integer when creating a list element from a numerical value.');\n\t\t\t\t}\n\n\t\t\t\tlet generatedListValue = null;\n\n\t\t\t\tif (this.listDefinitions === null) { return throwNullException('this.listDefinitions'); }\n\t\t\t\tlet foundListDef = this.listDefinitions.TryListGetDefinition(listNameVal.value, null);\n\t\t\t\tif (foundListDef.exists) {\n\t\t\t\t\t// Originally a primitive type, but here, can be null.\n\t\t\t\t\t// TODO: Replace by default value?\n\t\t\t\t\tif (intVal.value === null) { return throwNullException('minInt.value'); }\n\n\t\t\t\t\tlet foundItem = foundListDef.result!.TryGetItemWithValue(intVal.value, InkListItem.Null);\n\t\t\t\t\tif (foundItem.exists) {\n\t\t\t\t\t\tgeneratedListValue = new ListValue(foundItem.result!, intVal.value);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthrow new StoryException('Failed to find LIST called ' + listNameVal.value);\n\t\t\t\t}\n\n\t\t\t\tif (generatedListValue == null)\n\t\t\t\t\tgeneratedListValue = new ListValue();\n\n\t\t\t\tthis.state.PushEvaluationStack(generatedListValue);\n\t\t\t\tbreak;\n\n\t\t\tcase ControlCommand.CommandType.ListRange:\n\t\t\t\tlet max = asOrNull(this.state.PopEvaluationStack(), Value);\n\t\t\t\tlet min = asOrNull(this.state.PopEvaluationStack(), Value);\n\n\t\t\t\t// var targetList = state.PopEvaluationStack () as ListValue;\n\t\t\t\tlet targetList = asOrNull(this.state.PopEvaluationStack(), ListValue);\n\n\t\t\t\tif (targetList === null || min === null || max === null)\n\t\t\t\t\tthrow new StoryException('Expected list, minimum and maximum for LIST_RANGE');\n\n\t\t\t\tif (targetList.value === null) { return throwNullException('targetList.value'); }\n\t\t\t\tlet result = targetList.value.ListWithSubRange(min.valueObject, max.valueObject);\n\n\t\t\t\tthis.state.PushEvaluationStack (new ListValue(result));\n\t\t\t\tbreak;\n\n\t\t\tcase ControlCommand.CommandType.ListRandom: {\n\t\t\t\tlet listVal = this.state.PopEvaluationStack() as ListValue;\n\t\t\t\tif (listVal === null)\n\t\t\t\t\tthrow new StoryException('Expected list for LIST_RANDOM');\n\n\t\t\t\tlet list = listVal.value;\n\n\t\t\t\tlet newList: InkList | null = null;\n\n\t\t\t\tif (list === null) { throw throwNullException('list'); }\n\t\t\t\tif (list.Count == 0) {\n\t\t\t\t\tnewList = new InkList();\n\t\t\t\t} else {\n\t\t\t\t\t// Generate a random index for the element to take\n\t\t\t\t\tlet resultSeed = this.state.storySeed + this.state.previousRandom;\n\t\t\t\t\tlet random = new PRNG(resultSeed);\n\n\t\t\t\t\tlet nextRandom = random.next();\n\t\t\t\t\tlet listItemIndex = nextRandom % list.Count;\n\n\t\t\t\t\t// This bit is a little different from the original\n\t\t\t\t\t// C# code, since iterators do not work in the same way.\n\t\t\t\t\t// First, we iterate listItemIndex - 1 times, calling next().\n\t\t\t\t\t// The listItemIndex-th time is made outside of the loop,\n\t\t\t\t\t// in order to retrieve the value.\n\t\t\t\t\tlet listEnumerator = list.entries();\n\t\t\t\t\tfor (let i = 0; i <= listItemIndex - 1; i++) {\n\t\t\t\t\t\tlistEnumerator.next();\n\t\t\t\t\t}\n\t\t\t\t\tlet value = listEnumerator.next().value;\n\t\t\t\t\tlet randomItem: KeyValuePair<InkListItem, number> = {\n\t\t\t\t\t\tKey: InkListItem.fromSerializedKey(value[0]),\n\t\t\t\t\t\tValue: value[1],\n\t\t\t\t\t};\n\n\t\t\t\t\t// Origin list is simply the origin of the one element\n\t\t\t\t\tif (randomItem.Key.originName === null) { return throwNullException('randomItem.Key.originName'); }\n\t\t\t\t\tnewList = new InkList(randomItem.Key.originName, this);\n\t\t\t\t\tnewList.Add(randomItem.Key, randomItem.Value);\n\n\t\t\t\t\tthis.state.previousRandom = nextRandom;\n\t\t\t\t}\n\n\t\t\t\tthis.state.PushEvaluationStack(new ListValue(newList));\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tdefault:\n\t\t\t\tthis.Error('unhandled ControlCommand: ' + evalCommand);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\t// Variable assignment\n\t\telse if( contentObj instanceof VariableAssignment ) {\n\t\t\tlet varAss = contentObj;\n\t\t\tlet assignedVal = this.state.PopEvaluationStack();\n\n\t\t\tthis.state.variablesState.Assign(varAss, assignedVal);\n\n\t\t\treturn true;\n\t\t}\n\n\t\t// Variable reference\n\t\telse if( contentObj instanceof VariableReference ) {\n\t\t\tlet varRef = contentObj;\n\t\t\tlet foundValue = null;\n\n\t\t\t// Explicit read count value\n\t\t\tif (varRef.pathForCount != null) {\n\n\t\t\t\tlet container = varRef.containerForCount;\n\t\t\t\tlet count = this.VisitCountForContainer(container);\n\t\t\t\tfoundValue = new IntValue(count);\n\t\t\t}\n\n\t\t\t// Normal variable reference\n\t\t\telse {\n\n\t\t\t\tfoundValue = this.state.variablesState.GetVariableWithName(varRef.name);\n\n\t\t\t\tif (foundValue == null) {\n\t\t\t\t\tlet defaultVal = this.state.variablesState.TryGetDefaultVariableValue (varRef.name);\n\t\t\t\t\tif (defaultVal != null) {\n\t\t\t\t\t\tthis.Warning(\"Variable not found in save state: '\" + varRef.name + \"', but seems to have been newly created. Assigning value from latest ink's declaration: \" + defaultVal);\n\t\t\t\t\t\tfoundValue = defaultVal;\n\n\t\t\t\t\t\t// Save for future usage, preventing future errors\n\t\t\t\t\t\t// Only do this for variables that are known to be globals, not those that may be missing temps.\n\t\t\t\t\t\tthis.state.variablesState.SetGlobal(varRef.name, foundValue);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.Warning (\"Variable not found: '\" + varRef.name + \"'. Using default value of 0 (false). This can happen with temporary variables if the declaration hasn't yet been hit.\");\n\t\t\t\t\t\tfoundValue = new IntValue(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.state.PushEvaluationStack(foundValue);\n\n\t\t\treturn true;\n\t\t}\n\n\t\t// Native function call\n\t\telse if (contentObj instanceof NativeFunctionCall) {\n\t\t\tlet func = contentObj;\n\t\t\tlet funcParams = this.state.PopEvaluationStack(func.numberOfParameters);\n\t\t\tlet result = func.Call(funcParams);\n\t\t\tthis.state.PushEvaluationStack(result);\n\t\t\treturn true;\n\t\t}\n\n\t\t// No control content, must be ordinary content\n\t\treturn false;\n\t}\n\n\tpublic ChoosePathString(path: string, resetCallstack = true, args: any[] = []){\n\t\tthis.IfAsyncWeCant ('call ChoosePathString right now');\n\n\t\tif (resetCallstack) {\n\t\t\tthis.ResetCallstack();\n\t\t} else {\n\t\t\tif (this.state.callStack.currentElement.type == PushPopType.Function) {\n\t\t\t\tlet funcDetail = '';\n\t\t\t\tlet container = this.state.callStack.currentElement.currentPointer.container;\n\t\t\t\tif (container != null) {\n\t\t\t\t\tfuncDetail = '('+container.path.toString ()+') ';\n\t\t\t\t}\n\t\t\t\tthrow new Error('Story was running a function '+funcDetail+'when you called ChoosePathString('+path+') - this is almost certainly not not what you want! Full stack trace: \\n'+this.state.callStack.callStackTrace);\n\t\t\t}\n\t\t}\n\n\t\tthis.state.PassArgumentsToEvaluationStack(args);\n\t\tthis.ChoosePath(new Path(path));\n\t}\n\n\tpublic IfAsyncWeCant(activityStr: string)\n\t{\n\t\tif (this._asyncContinueActive)\n\t\t\tthrow new Error(\"Can't \" + activityStr + '. Story is in the middle of a ContinueAsync(). Make more ContinueAsync() calls or a single Continue() call beforehand.');\n\t}\n\n\tpublic ChoosePath(p: Path, incrementingTurnIndex: boolean = true){\n\t\tthis.state.SetChosenPath(p, incrementingTurnIndex);\n\n\t\t// Take a note of newly visited containers for read counts etc\n\t\tthis.VisitChangedContainersDueToDivert();\n\t}\n\n\tpublic ChooseChoiceIndex(choiceIdx: number){\n\t\tchoiceIdx = choiceIdx;\n\t\tlet choices = this.currentChoices;\n\t\tthis.Assert(choiceIdx >= 0 && choiceIdx < choices.length, 'choice out of range');\n\n\t\tlet choiceToChoose = choices[choiceIdx];\n\t\tif (choiceToChoose.threadAtGeneration === null) { return throwNullException('choiceToChoose.threadAtGeneration'); }\n\t\tif (choiceToChoose.targetPath === null) { return throwNullException('choiceToChoose.targetPath'); }\n\n\t\tthis.state.callStack.currentThread = choiceToChoose.threadAtGeneration;\n\n\t\tthis.ChoosePath(choiceToChoose.targetPath);\n\t}\n\n\tpublic HasFunction(functionName: string){\n\t\ttry {\n\t\t\treturn this.KnotContainerWithName(functionName) != null;\n\t\t} catch(e) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tpublic EvaluateFunction(functionName: string, args: any[] = [], returnTextOutput: boolean = false): Story.EvaluateFunctionTextOutput | any{\n\t\t// EvaluateFunction behaves slightly differently than the C# version.\n\t\t// In C#, you can pass a (second) parameter `out textOutput` to get the\n\t\t// text outputted by the function. This is not possible in js. Instead,\n\t\t// we maintain the regular signature (functionName, args), plus an\n\t\t// optional third parameter returnTextOutput. If set to true, we will\n\t\t// return both the textOutput and the returned value, as an object.\n\n\t\tthis.IfAsyncWeCant('evaluate a function');\n\n\t\tif (functionName == null) {\n\t\t\tthrow new Error('Function is null');\n\t\t}\n\t\telse if (functionName == '' || functionName.trim() == '') {\n\t\t\tthrow new Error('Function is empty or white space.');\n\t\t}\n\n\t\tlet funcContainer = this.KnotContainerWithName(functionName);\n\t\tif (funcContainer == null) {\n\t\t\tthrow new Error(\"Function doesn't exist: '\" + functionName + \"'\");\n\t\t}\n\n\t\tlet outputStreamBefore: InkObject[] = [];\n\t\toutputStreamBefore.push.apply(outputStreamBefore, this.state.outputStream);\n\t\tthis._state.ResetOutput();\n\n\t\tthis.state.StartFunctionEvaluationFromGame(funcContainer, args);\n\n\t\t// Evaluate the function, and collect the string output\n\t\tlet stringOutput = new StringBuilder();\n\t\twhile (this.canContinue) {\n\t\t\tstringOutput.Append(this.Continue());\n\t\t}\n\t\tlet textOutput = stringOutput.toString();\n\n\t\tthis._state.ResetOutput(outputStreamBefore);\n\n\t\tlet result = this.state.CompleteFunctionEvaluationFromGame();\n\n\t\treturn (returnTextOutput) ? {returned: result, output: textOutput} : result;\n\t}\n\n\tpublic EvaluateExpression(exprContainer: Container){\n\t\tlet startCallStackHeight = this.state.callStack.elements.length;\n\n\t\tthis.state.callStack.Push(PushPopType.Tunnel);\n\n\t\tthis._temporaryEvaluationContainer = exprContainer;\n\n\t\tthis.state.GoToStart();\n\n\t\tlet evalStackHeight = this.state.evaluationStack.length;\n\n\t\tthis.Continue();\n\n\t\tthis._temporaryEvaluationContainer = null;\n\n\t\t// Should have fallen off the end of the Container, which should\n\t\t// have auto-popped, but just in case we didn't for some reason,\n\t\t// manually pop to restore the state (including currentPath).\n\t\tif (this.state.callStack.elements.length > startCallStackHeight) {\n\t\t\tthis.state.PopCallStack();\n\t\t}\n\n\t\tlet endStackHeight = this.state.evaluationStack.length;\n\t\tif (endStackHeight > evalStackHeight) {\n\t\t\treturn this.state.PopEvaluationStack();\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tpublic allowExternalFunctionFallbacks: boolean = false;\n\n\tpublic CallExternalFunction(funcName: string | null, numberOfArguments: number){\n\t\tif (funcName === null) { return throwNullException('funcName'); }\n\t\tlet func = this._externals.get(funcName);\n\t\tlet fallbackFunctionContainer = null;\n\n\t\tlet foundExternal = typeof func !== 'undefined';\n\n\t\t// Try to use fallback function?\n\t\tif (!foundExternal) {\n\t\t\tif (this.allowExternalFunctionFallbacks) {\n\t\t\t\tfallbackFunctionContainer = this.KnotContainerWithName(funcName);\n\t\t\t\tthis.Assert(fallbackFunctionContainer !== null, \"Trying to call EXTERNAL function '\" + funcName + \"' which has not been bound, and fallback ink function could not be found.\");\n\n\t\t\t\t// Divert direct into fallback function and we're done\n\t\t\t\tthis.state.callStack.Push(\n\t\t\t\t\tPushPopType.Function,\n\t\t\t\t\tundefined,\n\t\t\t\t\tthis.state.outputStream.length,\n\t\t\t\t);\n\t\t\t\tthis.state.divertedPointer = Pointer.StartOf(fallbackFunctionContainer);\n\t\t\t\treturn;\n\n\t\t\t} else {\n\t\t\t\tthis.Assert(false, \"Trying to call EXTERNAL function '\" + funcName + \"' which has not been bound (and ink fallbacks disabled).\");\n\t\t\t}\n\t\t}\n\n\t\t// Pop arguments\n\t\tlet args: any[] = [];\n\t\tfor (let i = 0; i < numberOfArguments; ++i) {\n\t\t\t// var poppedObj = state.PopEvaluationStack () as Value;\n\t\t\tlet poppedObj = asOrThrows(this.state.PopEvaluationStack(), Value);\n\t\t\tlet valueObj = poppedObj.valueObject;\n\t\t\targs.push(valueObj);\n\t\t}\n\n\t\t// Reverse arguments from the order they were popped,\n\t\t// so they're the right way round again.\n\t\targs.reverse();\n\n\t\t// Run the function!\n\t\tlet funcResult = func!(args);\n\n\t\t// Convert return value (if any) to the a type that the ink engine can use\n\t\tlet returnObj = null;\n\t\tif (funcResult != null) {\n\t\t\treturnObj = Value.Create(funcResult);\n\t\t\tthis.Assert(returnObj !== null, 'Could not create ink value from returned object of type ' + (typeof funcResult));\n\t\t} else {\n\t\t\treturnObj = new Void();\n\t\t}\n\n\t\tthis.state.PushEvaluationStack(returnObj);\n\t}\n\n\tpublic BindExternalFunctionGeneral(funcName: string, func: Story.ExternalFunction){\n\t\tthis.IfAsyncWeCant('bind an external function');\n\t\tthis.Assert(!this._externals.has(funcName), \"Function '\" + funcName + \"' has already been bound.\");\n\t\tthis._externals.set(funcName, func);\n\t}\n\n\tpublic TryCoerce(value: any){\n\t\t// We're skipping type coercition in this implementation. First of, js\n\t\t// is loosely typed, so it's not that important. Secondly, there is no\n\t\t// clean way (AFAIK) for the user to describe what type of parameters\n\t\t// they expect.\n\t\treturn value;\n\t}\n\n\tpublic BindExternalFunction(funcName: string, func: Story.ExternalFunction){\n\t\tthis.Assert(func != null, \"Can't bind a null function\");\n\n\t\tthis.BindExternalFunctionGeneral(funcName, (args: any) => {\n\t\t\tthis.Assert(args.length >= func.length, 'External function expected ' + func.length + ' arguments');\n\n\t\t\tlet coercedArgs = [];\n\t\t\tfor (let i = 0, l = args.length; i < l; i++){\n\t\t\t\tcoercedArgs[i] = this.TryCoerce(args[i]);\n\t\t\t}\n\t\t\treturn func.apply(null, coercedArgs);\n\t\t});\n\t}\n\n\tpublic UnbindExternalFunction(funcName: string){\n\t\tthis.IfAsyncWeCant('unbind an external a function');\n\t\tthis.Assert(this._externals.has(funcName), \"Function '\" + funcName + \"' has not been bound.\");\n\t\tthis._externals.delete(funcName);\n\t}\n\n\tpublic ValidateExternalBindings(): void;\n\tpublic ValidateExternalBindings(c: Container | null, missingExternals: Set<string>): void;\n\tpublic ValidateExternalBindings(o: InkObject | null, missingExternals: Set<string>): void;\n\tpublic ValidateExternalBindings(){\n\n\t\tlet c: Container | null = null;\n\t\tlet o: InkObject | null = null;\n\t\tlet missingExternals: Set<string> = arguments[1] || new Set();\n\n\t\tif (arguments[0] instanceof Container) {\n\t\t\tc = arguments[0];\n\t\t}\n\n\t\tif (arguments[0] instanceof InkObject) {\n\t\t\to = arguments[0];\n\t\t}\n\n\t\tif (c === null && o === null) {\n\t\t\tthis.ValidateExternalBindings(this._mainContentContainer, missingExternals);\n\t\t\tthis._hasValidatedExternals = true;\n\n\t\t\t// No problem! Validation complete\n\t\t\tif( missingExternals.size == 0 ) {\n\t\t\t\tthis._hasValidatedExternals = true;\n\t\t\t} else {\n\t\t\t\tlet message = 'Error: Missing function binding for external';\n\t\t\t\tmessage += (missingExternals.size > 1) ? 's' : '';\n\t\t\t\tmessage += \": '\";\n\t\t\t\tmessage += Array.from(missingExternals).join(\"', '\");\n\t\t\t\tmessage += \"' \";\n\t\t\t\tmessage += (this.allowExternalFunctionFallbacks) ? ', and no fallback ink function found.' : ' (ink fallbacks disabled)';\n\n\t\t\t\tthis.Error(message);\n\t\t\t}\n\t\t} else if (c != null) {\n\t\t\tfor (let innerContent of c.content) {\n\t\t\t\tlet container = innerContent as Container;\n\t\t\t\tif (container == null || !container.hasValidName)\n\t\t\t\t\tthis.ValidateExternalBindings (innerContent, missingExternals);\n\t\t\t}\n\t\t\tfor (let [key, value] of c.namedContent) {\n\t\t\t\tthis.ValidateExternalBindings (asOrNull(value, InkObject), missingExternals);\n\t\t\t}\n\t\t} else if (o != null) {\n\t\t\tlet divert = asOrNull(o, Divert);\n\t\t\tif (divert && divert.isExternal) {\n\t\t\t\tlet name = divert.targetPathString;\n\t\t\t\tif (name === null) { return throwNullException('name'); }\n\t\t\t\tif (!this._externals.has(name)) {\n\t\t\t\t\tif (this.allowExternalFunctionFallbacks) {\n\t\t\t\t\t\tlet fallbackFound = this.mainContentContainer.namedContent.has(name);\n\t\t\t\t\t\tif (!fallbackFound) {\n\t\t\t\t\t\t\tmissingExternals.add(name);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmissingExternals.add(name);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic ObserveVariable(variableName: string, observer: Story.VariableObserver){\n\t\tthis.IfAsyncWeCant('observe a new variable');\n\n\t\tif (this._variableObservers === null)\n\t\t\tthis._variableObservers = new Map();\n\n\t\tif(!this.state.variablesState.GlobalVariableExistsWithName(variableName))\n\t\t\tthrow new StoryException(\"Cannot observe variable '\"+variableName+\"' because it wasn't declared in the ink story.\");\n\n\t\tif (this._variableObservers.has(variableName)) {\n\t\t\tthis._variableObservers.get(variableName)!.push(observer);\n\t\t} else {\n\t\t\tthis._variableObservers.set(variableName, [observer]);\n\t\t}\n\t}\n\n\tpublic ObserveVariables(variableNames: string[], observers: Story.VariableObserver[]){\n\t\tfor (let i = 0, l = variableNames.length; i < l; i++){\n\t\t\tthis.ObserveVariable(variableNames[i], observers[i]);\n\t\t}\n\t}\n\n\tpublic RemoveVariableObserver(observer: Story.VariableObserver, specificVariableName: string){\n\t\tthis.IfAsyncWeCant('remove a variable observer');\n\n\t\tif (this._variableObservers === null)\n\t\t\treturn;\n\n\t\tif (typeof specificVariableName !== 'undefined') {\n\t\t\tif (this._variableObservers.has(specificVariableName)) {\n\t\t\t\tlet observers = this._variableObservers.get(specificVariableName)!;\n\t\t\t\tobservers.splice(observers.indexOf(observer), 1);\n\t\t\t}\n\t\t} else {\n\t\t\tlet keys = this._variableObservers.keys();\n\n\t\t\tfor (let varName of keys){\n\t\t\t\tlet observers = this._variableObservers.get(varName)!;\n\t\t\t\tobservers.splice(observers.indexOf(observer), 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic VariableStateDidChangeEvent(variableName: string, newValueObj: InkObject){\n\t\tif (this._variableObservers === null)\n\t\t\treturn;\n\n\t\tlet observers = this._variableObservers.get(variableName);\n\t\tif (typeof observers !== 'undefined') {\n\t\t\tif (!(newValueObj instanceof Value)) {\n\t\t\t\tthrow new Error(\"Tried to get the value of a variable that isn't a standard type\");\n\t\t\t}\n\t\t\t// var val = newValueObj as Value;\n\t\t\tlet val = asOrThrows(newValueObj, Value);\n\n\t\t\tfor (let observer of observers) {\n\t\t\t\tobserver(variableName, val.valueObject);\n\t\t\t}\n\t\t}\n\t}\n\n\tget globalTags(){\n\t\treturn this.TagsAtStartOfFlowContainerWithPathString('');\n\t}\n\n\tpublic TagsForContentAtPath(path: string){\n\t\treturn this.TagsAtStartOfFlowContainerWithPathString(path);\n\t}\n\n\tpublic TagsAtStartOfFlowContainerWithPathString(pathString: string){\n\t\tlet path = new Path(pathString);\n\n\t\tlet flowContainer = this.ContentAtPath(path).container;\n\t\tif (flowContainer === null) { return throwNullException('flowContainer'); }\n\t\twhile(true) {\n\t\t\tlet firstContent: InkObject = flowContainer.content[0];\n\t\t\tif (firstContent instanceof Container)\n\t\t\t\tflowContainer = firstContent;\n\t\t\telse break;\n\t\t}\n\n\t\tlet tags: string[] | null = null;\n\n\t\tfor(let c of flowContainer.content) {\n\t\t\t// var tag = c as Runtime.Tag;\n\t\t\tlet tag = asOrNull(c, Tag);\n\t\t\tif (tag) {\n\t\t\t\tif (tags == null) tags = [];\n\t\t\t\ttags.push(tag.text);\n\t\t\t} else break;\n\t\t}\n\n\t\treturn tags;\n\t}\n\n\tpublic BuildStringOfHierarchy(){\n\t\tlet sb = new StringBuilder();\n\n\t\tthis.mainContentContainer.BuildStringOfHierarchy(sb, 0, this.state.currentPointer.Resolve());\n\n\t\treturn sb.toString();\n\t}\n\n\tpublic BuildStringOfContainer(container: Container){\n\t\tlet sb = new StringBuilder();\n\t\tcontainer.BuildStringOfHierarchy(sb, 0, this.state.currentPointer.Resolve());\n\t\treturn sb.toString();\n\t}\n\n\tpublic NextContent(){\n\t\tthis.state.previousPointer = this.state.currentPointer.copy();\n\n\t\tif (!this.state.divertedPointer.isNull) {\n\n\t\t\tthis.state.currentPointer = this.state.divertedPointer.copy();\n\t\t\tthis.state.divertedPointer = Pointer.Null;\n\n\t\t\tthis.VisitChangedContainersDueToDivert();\n\n\t\t\tif (!this.state.currentPointer.isNull) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tlet successfulPointerIncrement = this.IncrementContentPointer();\n\n\t\tif (!successfulPointerIncrement) {\n\n\t\t\tlet didPop = false;\n\n\t\t\tif (this.state.callStack.CanPop(PushPopType.Function)) {\n\n\t\t\t\tthis.state.PopCallStack(PushPopType.Function);\n\n\t\t\t\tif (this.state.inExpressionEvaluation) {\n\t\t\t\t\tthis.state.PushEvaluationStack(new Void());\n\t\t\t\t}\n\n\t\t\t\tdidPop = true;\n\t\t\t} else if (this.state.callStack.canPopThread) {\n\t\t\t\tthis.state.callStack.PopThread();\n\n\t\t\t\tdidPop = true;\n\t\t\t} else {\n\t\t\t\tthis.state.TryExitFunctionEvaluationFromGame();\n\t\t\t}\n\n\t\t\tif (didPop && !this.state.currentPointer.isNull) {\n\t\t\t\tthis.NextContent();\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic IncrementContentPointer(){\n\t\tlet successfulIncrement = true;\n\n\t\tlet pointer = this.state.callStack.currentElement.currentPointer.copy();\n\t\tpointer.index++;\n\n\t\tif (pointer.container === null) { return throwNullException('pointer.container'); }\n\t\twhile (pointer.index >= pointer.container.content.length) {\n\n\t\t\tsuccessfulIncrement = false;\n\n\t\t\t// Container nextAncestor = pointer.container.parent as Container;\n\t\t\tlet nextAncestor = asOrNull(pointer.container.parent, Container);\n\t\t\tif (nextAncestor instanceof Container === false) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlet indexInAncestor = nextAncestor!.content.indexOf(pointer.container);\n\t\t\tif (indexInAncestor == -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tpointer = new Pointer(nextAncestor, indexInAncestor);\n\n\t\t\tpointer.index++;\n\n\t\t\tsuccessfulIncrement = true;\n\t\t\tif (pointer.container === null) { return throwNullException('pointer.container'); }\n\t\t}\n\n\t\tif (!successfulIncrement) pointer = Pointer.Null;\n\n\t\tthis.state.callStack.currentElement.currentPointer = pointer.copy();\n\n\t\treturn successfulIncrement;\n\t}\n\n\tpublic TryFollowDefaultInvisibleChoice(){\n\t\tlet allChoices = this._state.currentChoices;\n\n\t\tlet invisibleChoices = allChoices.filter((c) => {\n\t\t\treturn c.isInvisibleDefault;\n\t\t});\n\n\t\tif (invisibleChoices.length == 0 || allChoices.length > invisibleChoices.length)\n\t\t\treturn false;\n\n\t\tlet choice = invisibleChoices[0];\n\n\t\tif (choice.targetPath === null) { return throwNullException('choice.targetPath'); }\n\n\t\tif (choice.threadAtGeneration === null) { return throwNullException('choice.threadAtGeneration'); }\n\n\t\tthis.state.callStack.currentThread = choice.threadAtGeneration;\n\n\t\tthis.ChoosePath(choice.targetPath, false);\n\n\t\treturn true;\n\t}\n\n\tpublic VisitCountForContainer(container: Container | null){\n\t\tif (container === null) { return throwNullException('container'); }\n\t\tif( !container.visitsShouldBeCounted ) {\n\t\t\tconsole.warn('Read count for target ('+container.name+' - on '+container.debugMetadata+') unknown. The story may need to be compiled with countAllVisits flag (-c).');\n\t\t\treturn 0;\n\t\t}\n\n\t\tlet count = 0;\n\t\tlet containerPathStr = container.path.toString();\n\t\tcount = this.state.visitCounts.get(containerPathStr) || count;\n\t\treturn count;\n\t}\n\n\tpublic IncrementVisitCountForContainer(container: Container){\n\t\tlet count = 0;\n\t\tlet containerPathStr = container.path.toString();\n\t\tif (this.state.visitCounts.has(containerPathStr)) count = this.state.visitCounts.get(containerPathStr)!;\n\t\tcount++;\n\t\tthis.state.visitCounts.set(containerPathStr, count);\n\t}\n\n\tpublic RecordTurnIndexVisitToContainer(container: Container){\n\t\tlet containerPathStr = container.path.toString();\n\t\tthis.state.turnIndices.set(containerPathStr, this.state.currentTurnIndex);\n\t}\n\n\tpublic TurnsSinceForContainer(container: Container){\n\t\tif( !container.turnIndexShouldBeCounted ) {\n\t\t\tthis.Error('TURNS_SINCE() for target ('+container.name+' - on '+container.debugMetadata+') unknown. The story may need to be compiled with countAllVisits flag (-c).');\n\t\t}\n\n\t\tlet containerPathStr = container.path.toString();\n\t\tlet index = this.state.turnIndices.get(containerPathStr);\n\t\tif (typeof index !== 'undefined') {\n\t\t\treturn this.state.currentTurnIndex - index;\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tpublic NextSequenceShuffleIndex(){\n\t\t// var numElementsIntVal = state.PopEvaluationStack () as IntValue;\n\t\tlet numElementsIntVal = asOrNull(this.state.PopEvaluationStack(), IntValue);\n\t\tif (!(numElementsIntVal instanceof IntValue)) {\n\t\t\tthis.Error('expected number of elements in sequence for shuffle index');\n\t\t\treturn 0;\n\t\t}\n\n\t\tlet seqContainer = this.state.currentPointer.container;\n\t\tif (seqContainer === null) { return throwNullException('seqContainer'); }\n\n\t\t// Originally a primitive type, but here, can be null.\n\t\t// TODO: Replace by default value?\n\t\tif (numElementsIntVal.value === null) { return throwNullException('numElementsIntVal.value'); }\n\t\tlet numElements = numElementsIntVal.value;\n\n\t\t// var seqCountVal = state.PopEvaluationStack () as IntValue;\n\t\tlet seqCountVal = asOrThrows(this.state.PopEvaluationStack(), IntValue);\n\t\tlet seqCount = seqCountVal.value;\n\n\t\t// Originally a primitive type, but here, can be null.\n\t\t// TODO: Replace by default value?\n\t\tif (seqCount === null) { return throwNullException('seqCount'); }\n\n\t\tlet loopIndex = seqCount / numElements;\n\t\tlet iterationIndex = seqCount % numElements;\n\n\t\tlet seqPathStr = seqContainer.path.toString();\n\t\tlet sequenceHash = 0;\n\t\tfor (let i = 0, l = seqPathStr.length; i < l; i++){\n\t\t\tsequenceHash += seqPathStr.charCodeAt(i) || 0;\n\t\t}\n\t\tlet randomSeed = sequenceHash + loopIndex + this.state.storySeed;\n\t\tlet random = new PRNG(Math.floor(randomSeed));\n\n\t\tlet unpickedIndices = [];\n\t\tfor (let i = 0; i < numElements; ++i) {\n\t\t\tunpickedIndices.push(i);\n\t\t}\n\n\t\tfor (let i = 0; i <= iterationIndex; ++i) {\n\t\t\tlet chosen = random.next() % unpickedIndices.length;\n\t\t\tlet chosenIndex = unpickedIndices[chosen];\n\t\t\tunpickedIndices.splice(chosen, 1);\n\n\t\t\tif (i == iterationIndex) {\n\t\t\t\treturn chosenIndex;\n\t\t\t}\n\t\t}\n\n\t\tthrow new Error('Should never reach here');\n\t}\n\n\tpublic Error(message: string, useEndLineNumber = false): never{\n\t\tlet e = new StoryException(message);\n\t\te.useEndLineNumber = useEndLineNumber;\n\t\tthrow e;\n\t}\n\n\tpublic Warning(message: string){\n\t\tthis.AddError(message, true);\n\t}\n\n\tpublic AddError(message: string, isWarning = false, useEndLineNumber = false){\n\t\tlet dm = this.currentDebugMetadata;\n\n\t\tlet errorTypeStr = isWarning ? 'WARNING' : 'ERROR';\n\n\t\tif (dm != null) {\n\t\t\tlet lineNum = useEndLineNumber ? dm.endLineNumber : dm.startLineNumber;\n\t\t\tmessage = 'RUNTIME ' + errorTypeStr + \": '\" + dm.fileName + \"' line \" + lineNum + ': ' + message;\n\t\t}\n\t\telse if(!this.state.currentPointer.isNull) {\n\t\t\tmessage = 'RUNTIME ' + errorTypeStr + ': (' + this.state.currentPointer + '): ' + message;\n\t\t}\n\t\telse {\n\t\t\tmessage = 'RUNTIME ' + errorTypeStr + ': ' + message;\n\t\t}\n\n\t\tthis.state.AddError(message, isWarning);\n\n\t\t// In a broken state don't need to know about any other errors.\n\t\tif (!isWarning)\n\t\t\tthis.state.ForceEnd();\n\t}\n\n\tpublic Assert(condition: boolean, message: string | null = null) {\n\t\tif (condition == false) {\n\t\t\tif (message == null) {\n\t\t\t\tmessage = 'Story assert';\n\t\t\t}\n\n\t\t\tthrow new Error(message + ' ' + this.currentDebugMetadata);\n\t\t}\n\t}\n\n\tget currentDebugMetadata(): DebugMetadata | null {\n\t\tlet dm: DebugMetadata | null;\n\n\t\tlet pointer = this.state.currentPointer;\n\t\tif (!pointer.isNull && pointer.Resolve() !== null) {\n\t\t\tdm = pointer.Resolve()!.debugMetadata;\n\t\t\tif (dm !== null) {\n\t\t\t\treturn dm;\n\t\t\t}\n\t\t}\n\n\t\tfor (let i = this.state.callStack.elements.length - 1; i >= 0; --i) {\n\t\t\tpointer = this.state.callStack.elements [i].currentPointer;\n\t\t\tif (!pointer.isNull && pointer.Resolve() !== null) {\n\t\t\t\tdm = pointer.Resolve()!.debugMetadata;\n\t\t\t\tif (dm !== null) {\n\t\t\t\t\treturn dm;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (let i = this.state.outputStream.length - 1; i >= 0; --i) {\n\t\t\tlet outputObj = this.state.outputStream [i];\n\t\t\tdm = outputObj.debugMetadata;\n\t\t\tif (dm !== null) {\n\t\t\t\treturn dm;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tget mainContentContainer(){\n\t\tif (this._temporaryEvaluationContainer) {\n\t\t\treturn this._temporaryEvaluationContainer;\n\t\t} else {\n\t\t\treturn this._mainContentContainer;\n\t\t}\n\t}\n\n\t/**\n\t * `_mainContentContainer` is almost guaranteed to be set in the\n\t * constructor, unless the json is malformed.\n\t */\n\tprivate _mainContentContainer!: Container;\n\tprivate _listDefinitions: ListDefinitionsOrigin | null = null;\n\n\tprivate _externals: Map<string, Story.ExternalFunction>;\n\tprivate _variableObservers: Map<string, Story.VariableObserver[]> | null = null;\n\tprivate _hasValidatedExternals: boolean = false;\n\n\tprivate _temporaryEvaluationContainer: Container | null = null;\n\n\t/**\n\t * `state` is almost guaranteed to be set in the constructor, unless\n\t * using the compiler-specific constructor which will likely not be used in\n\t * the real world.\n\t */\n\tprivate _state!: StoryState;\n\n\tprivate _asyncContinueActive: boolean = false;\n\tprivate _stateAtLastNewline: StoryState | null = null;\n\n\tprivate _recursiveContinueCount: number = 0;\n\n\tprivate _profiler: any | null = null; // TODO: Profiler\n}\n\nexport namespace Story{\n\texport enum OutputStateChange {\n\t\tNoChange = 0,\n\t\tExtendedBeyondNewline = 1,\n\t\tNewlineRemoved = 2,\n\t}\n\n\texport interface EvaluateFunctionTextOutput {\n\t\treturned: any;\n\t\toutput: string;\n\t}\n\n\texport type VariableObserver = (variableName: string, newValue: any) => void;\n\texport type ExternalFunction = (...args: any) => any;\n}\n","import {AbstractValue, Value, VariablePointerValue, ListValue} from './Value';\nimport {VariableAssignment} from './VariableAssignment';\nimport {InkObject} from './Object';\nimport {ListDefinitionsOrigin} from './ListDefinitionsOrigin';\nimport {StoryException} from './StoryException';\nimport {JsonSerialisation} from './JsonSerialisation';\nimport {asOrThrows, asOrNull} from './TypeAssertion';\nimport {tryGetValueFromMap} from './TryGetResult';\nimport {throwNullException} from './NullException';\nimport {CallStack} from './CallStack';\n\nexport class VariablesState{\n\t// The way variableChangedEvent is a bit different than the reference implementation.\n\t// Originally it uses the C# += operator to add delegates, but in js we need to maintain\n\t// an actual collection of delegates (ie. callbacks) to register a new one, there is a\n\t// special ObserveVariableChange method below.\n\tpublic variableChangedEventCallbacks: Array<(variableName: string, newValue: InkObject) => void> = [];\n\tpublic variableChangedEvent(variableName: string, newValue: InkObject): void {\n\t\tfor (let callback of this.variableChangedEventCallbacks) {\n\t\t\tcallback(variableName, newValue);\n\t\t}\n\t}\n\n\tget batchObservingVariableChanges(){\n\t\treturn this._batchObservingVariableChanges;\n\t}\n\tset batchObservingVariableChanges(value: boolean){\n\t\tthis._batchObservingVariableChanges = value;\n\t\tif (value) {\n\t\t\tthis._changedVariables = new Set();\n\t\t}\n\n\t\telse {\n\t\t\tif (this._changedVariables != null) {\n\t\t\t\tfor (let variableName of this._changedVariables) {\n\t\t\t\t\tlet currentValue = this._globalVariables.get(variableName);\n\t\t\t\t\tif (!currentValue) {\n\t\t\t\t\t\tthrowNullException('currentValue');\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.variableChangedEvent(variableName, currentValue);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tget callStack(){\n\t\treturn this._callStack;\n\t}\n\tset callStack(callStack){\n\t\tthis._callStack = callStack;\n\t}\n\n\tprivate _batchObservingVariableChanges: boolean = false;\n\n\t// the original code uses a magic getter and setter for global variables,\n\t// allowing things like variableState['varname]. This is not quite possible\n\t// in js without a Proxy, so it is replaced with this $ function.\n\tpublic $(variableName: string, value: InkObject){\n\t\tif (typeof value === 'undefined'){\n\t\t\tlet varContents = this._globalVariables.get(variableName);\n\n\t\t\tif ( typeof varContents === 'undefined' ) {\n\t\t\t\tvarContents = this._defaultGlobalVariables.get(variableName);\n\t\t\t}\n\n\t\t\tif ( typeof varContents !== 'undefined' )\n\t\t\t\treturn (varContents as AbstractValue).valueObject;\n\t\t\telse\n\t\t\t\treturn null;\n\t\t}\n\t\telse{\n\t\t\tif (typeof this._defaultGlobalVariables.get(variableName) === 'undefined')\n\t\t\t\tthrow new StoryException('Cannot assign to a variable ('+variableName+\") that hasn't been declared in the story\");\n\n\t\t\tlet val = Value.Create(value);\n\t\t\tif (val == null) {\n\t\t\t\tif (value == null) {\n\t\t\t\t\tthrow new StoryException('Cannot pass null to VariableState');\n\t\t\t\t} else {\n\t\t\t\t\tthrow new StoryException('Invalid value passed to VariableState: '+value.toString());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.SetGlobal(variableName, val);\n\t\t}\n\t}\n\n\tconstructor(callStack: CallStack, listDefsOrigin: ListDefinitionsOrigin | null){\n\t\tthis._globalVariables = new Map();\n\t\tthis._callStack = callStack;\n\t\tthis._listDefsOrigin = listDefsOrigin;\n\n\t\t// if es6 proxies are available, use them.\n\t\ttry{\n\t\t\t// the proxy is used to allow direct manipulation of global variables.\n\t\t\t// It first tries to access the objects own property, and if none is\n\t\t\t// found it delegates the call to the $ method, defined below\n\t\t\tlet p = new Proxy(this, {\n\t\t\t\tget(target: any, name){\n\t\t\t\t\treturn (name in target) ? target[name] : target.$(name);\n\t\t\t\t},\n\t\t\t\tset(target: any, name, value){\n\t\t\t\t\tif (name in target) target[name] = value;\n\t\t\t\t\telse target.$(name, value);\n\t\t\t\t\treturn true; // returning a falsy value make the trap fail\n\t\t\t\t},\n\t\t\t});\n\n\t\t\treturn p;\n\t\t}\n\t\tcatch(e){\n\t\t\t// thr proxy object is not available in this context. we should warn the\n\t\t\t// dev but writting to the console feels a bit intrusive.\n\t\t\t// console.log(\"ES6 Proxy not available - direct manipulation of global variables can't work, use $() instead.\");\n\t\t}\n\t}\n\n\tpublic CopyFrom(toCopy: VariablesState){\n\t\tthis._globalVariables = new Map(toCopy._globalVariables);\n\t\tthis._defaultGlobalVariables = new Map(toCopy._defaultGlobalVariables);\n\n\t\tthis.variableChangedEvent = toCopy.variableChangedEvent;\n\t\tthis.variableChangedEventCallbacks = toCopy.variableChangedEventCallbacks; // inkjs specificity that has to be copied along the rest of the structure\n\n\t\tif (toCopy.batchObservingVariableChanges != this.batchObservingVariableChanges) {\n\n\t\t\tif (toCopy.batchObservingVariableChanges) {\n\t\t\t\tthis._batchObservingVariableChanges = true;\n\t\t\t\tif (toCopy._changedVariables === null) { return throwNullException('toCopy._changedVariables'); }\n\t\t\t\tthis._changedVariables = new Set(toCopy._changedVariables);\n\t\t\t} else {\n\t\t\t\tthis._batchObservingVariableChanges = false;\n\t\t\t\tthis._changedVariables = null;\n\t\t\t}\n\t\t}\n\t}\n\n\tget jsonToken(){\n\t\treturn JsonSerialisation.DictionaryRuntimeObjsToJObject(this._globalVariables);\n\t}\n\tset jsonToken(value){\n\t\tthis._globalVariables = JsonSerialisation.JObjectToDictionaryRuntimeObjs(value);\n\t}\n\n\tpublic TryGetDefaultVariableValue(name: string | null): InkObject | null\n\t{\n\t\tlet val = tryGetValueFromMap(this._defaultGlobalVariables, name, null);\n\t\treturn val.exists ? val.result : null;\n\t}\n\n\tpublic GlobalVariableExistsWithName(name: string){\n\t\treturn this._globalVariables.has(name);\n\t}\n\n\tpublic GetVariableWithName(name: string | null, contextIndex: number = -1): InkObject | null {\n\t\tlet varValue = this.GetRawVariableWithName(name, contextIndex);\n\n\t\t// var varPointer = varValue as VariablePointerValue;\n\t\tlet varPointer = asOrNull(varValue, VariablePointerValue);\n\t\tif (varPointer !== null) {\n\t\t\tvarValue = this.ValueAtVariablePointer(varPointer);\n\t\t}\n\n\t\treturn varValue;\n\t}\n\n\tpublic GetRawVariableWithName(name: string | null, contextIndex: number) {\n\t\tlet varValue: InkObject | null = null;\n\n\t\tif (contextIndex == 0 || contextIndex == -1) {\n\t\t\t// this is a conditional assignment\n\t\t\tlet variableValue = tryGetValueFromMap(this._globalVariables, name, null);\n\t\t\tif (variableValue.exists)\n\t\t\t\treturn variableValue.result;\n\n\t\t\tif (this._listDefsOrigin === null) return throwNullException('VariablesState._listDefsOrigin');\n\t\t\tlet listItemValue = this._listDefsOrigin.FindSingleItemListWithName(name);\n\t\t\tif (listItemValue)\n\t\t\t\treturn listItemValue;\n\t\t}\n\n\t\tvarValue = this._callStack.GetTemporaryVariableWithName(name, contextIndex);\n\n\t\treturn varValue;\n\t}\n\n\tpublic ValueAtVariablePointer(pointer: VariablePointerValue){\n\t\t return this.GetVariableWithName(pointer.variableName, pointer.contextIndex);\n\t}\n\n\tpublic Assign(varAss: VariableAssignment, value: InkObject){\n\t\tlet name = varAss.variableName;\n\t\tif (name === null) { return throwNullException('name'); }\n\t\tlet contextIndex = -1;\n\n\t\tlet setGlobal = false;\n\t\tif (varAss.isNewDeclaration) {\n\t\t\tsetGlobal = varAss.isGlobal;\n\t\t} else {\n\t\t\tsetGlobal = this._globalVariables.has(name);\n\t\t}\n\n\t\tif (varAss.isNewDeclaration) {\n\t\t\t// var varPointer = value as VariablePointerValue;\n\t\t\tlet varPointer = asOrNull(value, VariablePointerValue);\n\t\t\tif (varPointer !== null) {\n\t\t\t\tlet fullyResolvedVariablePointer = this.ResolveVariablePointer(varPointer);\n\t\t\t\tvalue = fullyResolvedVariablePointer;\n\t\t\t}\n\n\t\t}\n\n\t\telse {\n\n\t\t\tlet existingPointer = null;\n\t\t\tdo {\n\t\t\t\t// existingPointer = GetRawVariableWithName (name, contextIndex) as VariablePointerValue;\n\t\t\t\texistingPointer = asOrNull(this.GetRawVariableWithName(name, contextIndex), VariablePointerValue);\n\t\t\t\tif (existingPointer != null) {\n\t\t\t\t\tname = existingPointer.variableName;\n\t\t\t\t\tcontextIndex = existingPointer.contextIndex;\n\t\t\t\t\tsetGlobal = (contextIndex == 0);\n\t\t\t\t}\n\t\t\t} while(existingPointer != null);\n\t\t}\n\n\t\tif (setGlobal) {\n\t\t\tthis.SetGlobal(name, value);\n\t\t} else {\n\t\t\tthis._callStack.SetTemporaryVariable(name, value, varAss.isNewDeclaration, contextIndex);\n\t\t}\n\t}\n\n\tpublic SnapshotDefaultGlobals(){\n\t\tthis._defaultGlobalVariables = new Map(this._globalVariables);\n\t}\n\n\tpublic RetainListOriginsForAssignment(oldValue: InkObject, newValue: InkObject){\n\t\tlet oldList = asOrThrows(oldValue, ListValue);\n\t\tlet newList = asOrThrows(newValue, ListValue);\n\n\t\tif (oldList.value && newList.value && newList.value.Count == 0) {\n\t\t\tnewList.value.SetInitialOriginNames(oldList.value.originNames);\n\t\t}\n\t}\n\n\tpublic SetGlobal(variableName: string | null, value: InkObject){\n\t\tlet oldValue = tryGetValueFromMap(this._globalVariables, variableName, null);\n\n\t\tif (oldValue.exists) {\n\t\t\tListValue.RetainListOriginsForAssignment(oldValue.result!, value);\n\t\t}\n\n\t\tif (variableName === null) { return throwNullException('variableName'); }\n\t\tthis._globalVariables.set(variableName, value);\n\n\t\t// TODO: Not sure !== is equivalent to !value.Equals(oldValue)\n\t\tif (this.variableChangedEvent != null && value !== oldValue.result) {\n\n\t\t\tif (this.batchObservingVariableChanges) {\n\t\t\t\tif (this._changedVariables === null) { return throwNullException('this._changedVariables'); }\n\t\t\t\tthis._changedVariables.add(variableName);\n\t\t\t} else {\n\t\t\t\tthis.variableChangedEvent(variableName, value);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic ResolveVariablePointer(varPointer: VariablePointerValue){\n\t\tlet contextIndex = varPointer.contextIndex;\n\n\t\tif( contextIndex == -1 )\n\t\t\tcontextIndex = this.GetContextIndexOfVariableNamed(varPointer.variableName);\n\n\t\tlet valueOfVariablePointedTo = this.GetRawVariableWithName(varPointer.variableName, contextIndex);\n\n\t\t// var doubleRedirectionPointer = valueOfVariablePointedTo as VariablePointerValue;\n\t\tlet doubleRedirectionPointer = asOrNull(valueOfVariablePointedTo, VariablePointerValue);\n\t\tif (doubleRedirectionPointer != null) {\n\t\t\treturn doubleRedirectionPointer;\n\t\t}\n\n\t\telse {\n\t\t\treturn new VariablePointerValue(varPointer.variableName, contextIndex);\n\t\t}\n\t}\n\n\tpublic GetContextIndexOfVariableNamed(varName: string){\n\t\tif (this._globalVariables.get(varName))\n\t\t\treturn 0;\n\n\t\treturn this._callStack.currentElementIndex;\n\t}\n\n\t\t/**\n\t\t * This function is specific to the js version of ink. It allows to register a\n\t\t * callback that will be called when a variable changes. The original code uses\n\t\t * `state.variableChangedEvent += callback` instead.\n\t\t * @param {function} callback\n\t\t */\n\tpublic ObserveVariableChange(callback: (variableName: string, newValue: InkObject) => void){\n\t\tthis.variableChangedEventCallbacks.push(callback);\n\t}\n\n\tprivate _globalVariables: Map<string, InkObject>;\n\tprivate _defaultGlobalVariables: Map<string, InkObject> = new Map();\n\n\tprivate _callStack: CallStack;\n\tprivate _changedVariables: Set<string> | null = new Set();\n\tprivate _listDefsOrigin: ListDefinitionsOrigin | null;\n}\n","// Taken from https://gist.github.com/blixt/f17b47c62508be59987b\n// Ink uses a seedable PRNG of which there is none in native javascript.\nexport class PRNG{\n\n\tprivate seed: number;\n\n\tconstructor(seed: number){\n\t\tthis.seed = seed % 2147483647;\n\t\tif (this.seed <= 0) this.seed += 2147483646;\n\t}\n\tpublic next(): number{\n\t\treturn this.seed = this.seed * 16807 % 2147483647;\n\t}\n\tpublic nextFloat(): number{\n\t\treturn (this.next() - 1) / 2147483646;\n\t}\n}\n","import {CallStack} from './CallStack';\nimport {VariablesState} from './VariablesState';\nimport {ValueType, Value, StringValue, ListValue} from './Value';\nimport {PushPopType} from './PushPop';\nimport {Tag} from './Tag';\nimport {Glue} from './Glue';\nimport {Path} from './Path';\nimport {ControlCommand} from './ControlCommand';\nimport {StoryException} from './StoryException';\nimport {StringBuilder} from './StringBuilder';\nimport {JsonSerialisation} from './JsonSerialisation';\nimport {PRNG} from './PRNG';\nimport {Void} from './Void';\nimport {Pointer} from './Pointer';\nimport {tryGetValueFromMap} from './TryGetResult';\nimport {Choice} from './Choice';\nimport {asOrNull, asOrThrows, nullIfUndefined} from './TypeAssertion';\nimport {JObject} from './JObject';\nimport {Debug} from './Debug';\nimport {Container} from './Container';\nimport {InkObject} from './Object';\nimport { throwNullException } from './NullException';\nimport { Story } from './Story';\n\nexport class StoryState{\n\n\tpublic readonly kInkSaveStateVersion = 8;\n\tpublic readonly kMinCompatibleLoadVersion = 8;\n\n\tpublic ToJson(indented: boolean = false){\n\t\treturn JSON.stringify(this.jsonToken, null, (indented) ? 2 : 0);\n\t}\n\tpublic toJson(indented: boolean = false){\n\t\treturn this.ToJson(indented);\n\t}\n\n\tpublic LoadJson(json: string){\n\t\tthis.jsonToken = JSON.parse(json);\n\t}\n\n\tpublic VisitCountAtPathString(pathString: string){\n\t\tlet visitCountOut = tryGetValueFromMap(this.visitCounts, pathString, null);\n\t\tif (visitCountOut.exists)\n\t\t\treturn visitCountOut.result;\n\n\t\treturn 0;\n\t}\n\n\tget callstackDepth(){\n\t\treturn this.callStack.depth;\n\t}\n\n\tget outputStream(){\n\t\treturn this._outputStream;\n\t}\n\n\tget currentChoices(){\n\t\t// If we can continue generating text content rather than choices,\n\t\t// then we reflect the choice list as being empty, since choices\n\t\t// should always come at the end.\n\t\tif ( this.canContinue ) return [];\n\t\treturn this._currentChoices;\n\t}\n\n\tget generatedChoices(){\n\t\treturn this._currentChoices;\n\t}\n\n\tget currentErrors(){\n\t\treturn this._currentErrors;\n\t}\n\tprivate _currentErrors: string[] | null = null;\n\n\tget currentWarnings(){\n\t\treturn this._currentWarnings;\n\t}\n\tprivate _currentWarnings: string[] | null = null;\n\n\tget variablesState(){\n\t\treturn this._variablesState;\n\t}\n\tprivate _variablesState: VariablesState;\n\n\tpublic callStack: CallStack;\n\n\tget evaluationStack(){\n\t\treturn this._evaluationStack;\n\t}\n\tprivate _evaluationStack: InkObject[];\n\n\tpublic divertedPointer: Pointer = Pointer.Null;\n\n\tget visitCounts(){\n\t\treturn this._visitCounts;\n\t}\n\tprivate _visitCounts: Map<string, number>;\n\n\tget turnIndices(){\n\t\treturn this._turnIndices;\n\t}\n\tprivate _turnIndices: Map<string, number>;\n\n\tget currentTurnIndex(){\n\t\treturn this._currentTurnIndex;\n\t}\n\tprivate _currentTurnIndex: number = 0;\n\n\tpublic storySeed: number = 0;\n\tpublic previousRandom: number = 0;\n\tpublic didSafeExit: boolean = false;\n\n\tpublic story: Story;\n\n\tget currentPathString(){\n\t\tlet pointer = this.currentPointer;\n\t\tif (pointer.isNull) {\n\t\t\treturn null;\n\t\t} else {\n\t\t\tif (pointer.path === null) { return throwNullException('pointer.path'); }\n\t\t\treturn pointer.path.toString();\n\t\t}\n\t}\n\n\tget currentPointer(){\n\t\treturn this.callStack.currentElement.currentPointer.copy();\n\t}\n\n\tset currentPointer(value){\n\t\tthis.callStack.currentElement.currentPointer = value.copy();\n\t}\n\n\tget previousPointer(){\n\t\treturn this.callStack.currentThread.previousPointer.copy();\n\t}\n\n\tset previousPointer(value){\n\t\tthis.callStack.currentThread.previousPointer = value.copy();\n\t}\n\n\tget canContinue(){\n\t\treturn !this.currentPointer.isNull && !this.hasError;\n\t}\n\n\tget hasError(){\n\t\treturn this.currentErrors != null && this.currentErrors.length > 0;\n\t}\n\n\tget hasWarning(){\n\t\treturn this.currentWarnings != null && this.currentWarnings.length > 0;\n\t}\n\n\tget currentText(){\n\t\tif( this._outputStreamTextDirty ) {\n\t\t\tlet sb = new StringBuilder();\n\n\t\t\tfor (let outputObj of this._outputStream) {\n\t\t\t\t// var textContent = outputObj as StringValue;\n\t\t\t\tlet textContent = asOrNull(outputObj, StringValue);\n\t\t\t\tif (textContent !== null) {\n\t\t\t\t\tsb.Append(textContent.value);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._currentText = this.CleanOutputWhitespace(sb.toString());\n\t\t\tthis._outputStreamTextDirty = false;\n\t\t}\n\n\t\treturn this._currentText;\n\t}\n\tprivate _currentText: string | null = null;\n\n\tpublic CleanOutputWhitespace(str: string){\n\t\tlet sb = new StringBuilder();\n\n\t\tlet currentWhitespaceStart = -1;\n\t\tlet startOfLine = 0;\n\n\t\tfor (let i = 0; i < str.length; i++) {\n\t\t\tlet c = str.charAt(i);\n\n\t\t\tlet isInlineWhitespace = (c == ' ') || (c == '\\t');\n\n\t\t\tif (isInlineWhitespace && currentWhitespaceStart == -1)\n\t\t\t\tcurrentWhitespaceStart = i;\n\n\t\t\tif (!isInlineWhitespace) {\n\t\t\t\tif (c != '\\n' && currentWhitespaceStart > 0 && currentWhitespaceStart != startOfLine) {\n\t\t\t\t\tsb.Append(' ');\n\t\t\t\t}\n\t\t\t\tcurrentWhitespaceStart = -1;\n\t\t\t}\n\n\t\t\tif (c == '\\n')\n\t\t\t\tstartOfLine = i + 1;\n\n\t\t\tif (!isInlineWhitespace)\n\t\t\t\tsb.Append(c);\n\t\t}\n\n\t\treturn sb.toString();\n\t}\n\n\tget currentTags(){\n\t\tif( this._outputStreamTagsDirty ) {\n\t\t\tthis._currentTags = [];\n\n\t\t\tfor(let outputObj of this._outputStream) {\n\t\t\t\t// var tag = outputObj as Tag;\n\t\t\t\tlet tag = asOrNull(outputObj, Tag);\n\t\t\t\tif (tag !== null) {\n\t\t\t\t\tthis._currentTags.push(tag.text);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._outputStreamTagsDirty = false;\n\t\t}\n\n\t\treturn this._currentTags;\n\t}\n\tprivate _currentTags: string[] | null = null;\n\n\tget inExpressionEvaluation(){\n\t\treturn this.callStack.currentElement.inExpressionEvaluation;\n\t}\n\tset inExpressionEvaluation(value){\n\t\tthis.callStack.currentElement.inExpressionEvaluation = value;\n\t}\n\n\tconstructor(story: Story){\n\t\tthis.story = story;\n\n\t\tthis._outputStream = [];\n\t\tthis.OutputStreamDirty();\n\n\t\tthis._evaluationStack = [];\n\n\t\tthis.callStack = new CallStack(story);\n\t\tthis._variablesState = new VariablesState(this.callStack, story.listDefinitions);\n\n\t\tthis._visitCounts = new Map();\n\t\tthis._turnIndices = new Map();\n\t\tthis._currentTurnIndex = -1;\n\n\t\tlet timeSeed = (new Date()).getTime();\n\t\tthis.storySeed = (new PRNG(timeSeed)).next() % 100;\n\t\tthis.previousRandom = 0;\n\n\t\tthis._currentChoices = [];\n\n\t\tthis.GoToStart();\n\t}\n\n\tpublic GoToStart(){\n\t\tthis.callStack.currentElement.currentPointer = Pointer.StartOf(this.story.mainContentContainer);\n\t}\n\n\tpublic Copy(){\n\t\tlet copy = new StoryState(this.story);\n\n\t\tcopy.outputStream.push.apply(copy.outputStream, this._outputStream);\n\t\tthis.OutputStreamDirty();\n\n\t\tcopy._currentChoices.push.apply(copy._currentChoices, this._currentChoices);\n\n\t\tif (this.hasError) {\n\t\t\tcopy._currentErrors = [];\n\t\t\tcopy._currentErrors.push.apply(copy._currentErrors, this.currentErrors || []);\n\t\t}\n\n\t\tif (this.hasWarning) {\n\t\t\tcopy._currentWarnings = [];\n\t\t\tcopy._currentWarnings.push.apply(copy._currentWarnings, this.currentWarnings || []);\n\t\t}\n\n\t\tcopy.callStack = new CallStack(this.callStack);\n\n\t\tcopy._variablesState = new VariablesState(copy.callStack, this.story.listDefinitions);\n\t\tcopy.variablesState.CopyFrom(this.variablesState);\n\n\t\tcopy.evaluationStack.push.apply(copy.evaluationStack, this.evaluationStack);\n\n\t\tif (!this.divertedPointer.isNull)\n\t\t\tcopy.divertedPointer = this.divertedPointer.copy();\n\n\t\tcopy.previousPointer = this.previousPointer.copy();\n\n\t\tcopy._visitCounts = new Map(this.visitCounts);\n\t\tcopy._turnIndices = new Map(this.turnIndices);\n\n\t\tcopy._currentTurnIndex = this.currentTurnIndex;\n\t\tcopy.storySeed = this.storySeed;\n\t\tcopy.previousRandom = this.previousRandom;\n\n\t\tcopy.didSafeExit = this.didSafeExit;\n\n\t\treturn copy;\n\t}\n\n\tget jsonToken(){\n\t\tlet obj: JObject = {};\n\n\t\tlet choiceThreads: JObject | undefined;\n\t\tfor (let c of this._currentChoices) {\n\t\t\tif (c.threadAtGeneration === null) { return throwNullException('c.threadAtGeneration'); }\n\t\t\tc.originalThreadIndex = c.threadAtGeneration.threadIndex;\n\n\t\t\tif( this.callStack.ThreadWithIndex(c.originalThreadIndex) == null ) {\n\t\t\t\tif( choiceThreads == null )\n\t\t\t\t\tchoiceThreads = new Map();\n\n\t\t\t\tchoiceThreads[c.originalThreadIndex.toString()] = c.threadAtGeneration.jsonToken;\n\t\t\t}\n\t\t}\n\n\t\tif (choiceThreads != null)\n\t\t\tobj['choiceThreads'] = choiceThreads;\n\n\t\tobj['callstackThreads'] = this.callStack.GetJsonToken();\n\t\tobj['variablesState'] = this.variablesState.jsonToken;\n\n\t\tobj['evalStack'] = JsonSerialisation.ListToJArray(this.evaluationStack);\n\n\t\tobj['outputStream'] = JsonSerialisation.ListToJArray(this._outputStream);\n\n\t\tobj['currentChoices'] = JsonSerialisation.ListToJArray(this._currentChoices);\n\n\t\tif(!this.divertedPointer.isNull) {\n\t\t\tif (this.divertedPointer.path === null) { return throwNullException('this.divertedPointer.path'); }\n\t\t\tobj['currentDivertTarget'] = this.divertedPointer.path.componentsString;\n\t\t}\n\n\t\tobj['visitCounts'] = JsonSerialisation.IntDictionaryToJObject(this.visitCounts);\n\t\tobj['turnIndices'] = JsonSerialisation.IntDictionaryToJObject(this.turnIndices);\n\t\tobj['turnIdx'] = this.currentTurnIndex;\n\t\tobj['storySeed'] = this.storySeed;\n\t\tobj['previousRandom'] = this.previousRandom;\n\n\t\tobj['inkSaveVersion'] = this.kInkSaveStateVersion;\n\n\t\t// Not using this right now, but could do in future.\n\t\tobj['inkFormatVersion'] = this.story.inkVersionCurrent;\n\n\t\treturn obj;\n\t}\n\tset jsonToken(value: JObject){\n\t\tlet jObject = value;\n\n\t\tlet jSaveVersion = jObject['inkSaveVersion'];\n\t\tif (jSaveVersion == null) {\n\t\t\tthrow new StoryException(\"ink save format incorrect, can't load.\");\n\t\t}\n\t\telse if (parseInt(jSaveVersion) < this.kMinCompatibleLoadVersion) {\n\t\t\tthrow new StoryException(\"Ink save format isn't compatible with the current version (saw '\"+jSaveVersion+\"', but minimum is \"+this.kMinCompatibleLoadVersion+\"), so can't load.\");\n\t\t}\n\n\t\tthis.callStack.SetJsonToken(jObject['callstackThreads'], this.story);\n\t\tthis.variablesState.jsonToken = jObject['variablesState'];\n\n\t\tthis._evaluationStack = JsonSerialisation.JArrayToRuntimeObjList(jObject['evalStack']);\n\n\t\tthis._outputStream = JsonSerialisation.JArrayToRuntimeObjList(jObject['outputStream']);\n\t\tthis.OutputStreamDirty();\n\n\t\t// currentChoices = Json.JArrayToRuntimeObjList<Choice>((JArray)jObject [\"currentChoices\"]);\n\t\tthis._currentChoices = JsonSerialisation.JArrayToRuntimeObjList(jObject['currentChoices']) as Choice[];\n\n\t\tlet currentDivertTargetPath = jObject['currentDivertTarget'];\n\t\tif (currentDivertTargetPath != null) {\n\t\t\tlet divertPath = new Path(currentDivertTargetPath.toString());\n\t\t\tthis.divertedPointer = this.story.PointerAtPath(divertPath);\n\t\t}\n\n\t\tthis._visitCounts = JsonSerialisation.JObjectToIntDictionary(jObject['visitCounts']) as Map<string, number>;\n\t\tthis._turnIndices = JsonSerialisation.JObjectToIntDictionary(jObject['turnIndices']) as Map<string, number>;\n\t\tthis._currentTurnIndex = parseInt(jObject['turnIdx']);\n\t\tthis.storySeed = parseInt(jObject['storySeed']);\n\t\tthis.previousRandom = parseInt(jObject['previousRandom']);\n\n\t\t// var jChoiceThreads = jObject[\"choiceThreads\"] as JObject;\n\t\tlet jChoiceThreads = jObject['choiceThreads'];\n\n\t\tfor(let c of this._currentChoices) {\n\t\t\tlet foundActiveThread = this.callStack.ThreadWithIndex(c.originalThreadIndex);\n\t\t\tif( foundActiveThread != null ) {\n\t\t\t\tc.threadAtGeneration = foundActiveThread.Copy();\n\t\t\t} else {\n\t\t\t\tlet jSavedChoiceThread = jChoiceThreads[c.originalThreadIndex.toString()];\n\t\t\t\tc.threadAtGeneration = new CallStack.Thread(jSavedChoiceThread, this.story);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic ResetErrors(){\n\t\tthis._currentErrors = null;\n\t\tthis._currentWarnings = null;\n\t}\n\tpublic ResetOutput(objs: InkObject[] | null = null){\n\t\tthis._outputStream.length = 0;\n\t\tif (objs !== null) this._outputStream.push.apply(this._outputStream, objs);\n\t\tthis.OutputStreamDirty();\n\t}\n\n\tpublic PushToOutputStream(obj: InkObject | null){\n\t\t// var text = obj as StringValue;\n\t\tlet text = asOrNull(obj, StringValue);\n\t\tif (text !== null) {\n\t\t\tlet listText = this.TrySplittingHeadTailWhitespace(text);\n\t\t\tif (listText !== null) {\n\t\t\t\tfor(let textObj of listText) {\n\t\t\t\t\tthis.PushToOutputStreamIndividual(textObj);\n\t\t\t\t}\n\t\t\t\tthis.OutputStreamDirty();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tthis.PushToOutputStreamIndividual(obj);\n\t\tthis.OutputStreamDirty();\n\t}\n\n\tpublic PopFromOutputStream(count: number){\n\t\tthis.outputStream.splice(this.outputStream.length - count, count);\n\t\tthis.OutputStreamDirty();\n\t}\n\n\tpublic TrySplittingHeadTailWhitespace(single: StringValue) {\n\t\tlet str = single.value;\n\t\tif (str === null) { return throwNullException('single.value'); }\n\n\t\tlet headFirstNewlineIdx = -1;\n\t\tlet headLastNewlineIdx = -1;\n\t\tfor (let i = 0; i < str.length; ++i) {\n\t\t\tlet c = str[i];\n\t\t\tif (c == '\\n') {\n\t\t\t\tif (headFirstNewlineIdx == -1)\n\t\t\t\t\theadFirstNewlineIdx = i;\n\t\t\t\theadLastNewlineIdx = i;\n\t\t\t}\n\t\t\telse if (c == ' ' || c == '\\t')\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\n\t\tlet tailLastNewlineIdx = -1;\n\t\tlet tailFirstNewlineIdx = -1;\n\t\tfor (let i = 0; i < str.length; ++i) {\n\t\t\tlet c = str[i];\n\t\t\tif (c == '\\n') {\n\t\t\t\tif (tailLastNewlineIdx == -1)\n\t\t\t\t\ttailLastNewlineIdx = i;\n\t\t\t\ttailFirstNewlineIdx = i;\n\t\t\t}\n\t\t\telse if (c == ' ' || c == '\\t')\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\n\t\t// No splitting to be done?\n\t\tif (headFirstNewlineIdx == -1 && tailLastNewlineIdx == -1)\n\t\t\treturn null;\n\n\t\tlet listTexts: StringValue[] = [];\n\t\tlet innerStrStart = 0;\n\t\tlet innerStrEnd = str.length;\n\n\t\tif (headFirstNewlineIdx != -1) {\n\t\t\tif (headFirstNewlineIdx > 0) {\n\t\t\t\tlet leadingSpaces = new StringValue(str.substring(0, headFirstNewlineIdx));\n\t\t\t\tlistTexts.push(leadingSpaces);\n\t\t\t}\n\t\t\tlistTexts.push(new StringValue('\\n'));\n\t\t\tinnerStrStart = headLastNewlineIdx + 1;\n\t\t}\n\n\t\tif (tailLastNewlineIdx != -1) {\n\t\t\tinnerStrEnd = tailFirstNewlineIdx;\n\t\t}\n\n\t\tif (innerStrEnd > innerStrStart) {\n\t\t\tlet innerStrText = str.substring(innerStrStart, innerStrEnd - innerStrStart);\n\t\t\tlistTexts.push(new StringValue(innerStrText));\n\t\t}\n\n\t\tif (tailLastNewlineIdx != -1 && tailFirstNewlineIdx > headLastNewlineIdx) {\n\t\t\tlistTexts.push(new StringValue('\\n'));\n\t\t\tif (tailLastNewlineIdx < str.length - 1) {\n\t\t\t\tlet numSpaces = (str.length - tailLastNewlineIdx) - 1;\n\t\t\t\tlet trailingSpaces = new StringValue(str.substring(tailLastNewlineIdx + 1, numSpaces));\n\t\t\t\tlistTexts.push(trailingSpaces);\n\t\t\t}\n\t\t}\n\n\t\treturn listTexts;\n\t}\n\n\tpublic PushToOutputStreamIndividual(obj: InkObject | null){\n\t\tlet glue = asOrNull(obj, Glue);\n\t\tlet text = asOrNull(obj, StringValue);\n\n\t\tlet includeInOutput = true;\n\n\t\tif (glue) {\n\t\t\tthis.TrimNewlinesFromOutputStream();\n\t\t\tincludeInOutput = true;\n\t\t}\n\n\t\telse if( text ) {\n\n\t\t\tlet functionTrimIndex = -1;\n\t\t\tlet currEl = this.callStack.currentElement;\n\t\t\tif (currEl.type == PushPopType.Function) {\n\t\t\t\tfunctionTrimIndex = currEl.functionStartInOutputStream;\n\t\t\t}\n\n\t\t\tlet glueTrimIndex = -1;\n\t\t\tfor (let i = this._outputStream.length - 1; i >= 0; i--) {\n\t\t\t\tlet o = this._outputStream[i];\n\t\t\t\tlet c = (o instanceof ControlCommand) ? o : null;\n\t\t\t\tlet g = (o instanceof Glue) ? o : null;\n\n\t\t\t\tif (g != null) {\n\t\t\t\t\tglueTrimIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\telse if (c != null && c.commandType == ControlCommand.CommandType.BeginString) {\n\t\t\t\t\tif (i >= functionTrimIndex) {\n\t\t\t\t\t\tfunctionTrimIndex = -1;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet trimIndex = -1;\n\t\t\tif (glueTrimIndex != -1 && functionTrimIndex != -1)\n\t\t\t\ttrimIndex = Math.min(functionTrimIndex, glueTrimIndex);\n\t\t\telse if (glueTrimIndex != -1)\n\t\t\t\ttrimIndex = glueTrimIndex;\n\t\t\telse\n\t\t\t\ttrimIndex = functionTrimIndex;\n\n\t\t\tif (trimIndex != -1) {\n\n\t\t\t\tif (text.isNewline) {\n\t\t\t\t\tincludeInOutput = false;\n\t\t\t\t}\n\n\t\t\t\telse if (text.isNonWhitespace) {\n\n\t\t\t\t\tif (glueTrimIndex > -1)\n\t\t\t\t\t\tthis.RemoveExistingGlue();\n\n\t\t\t\t\tif (functionTrimIndex > -1) {\n\t\t\t\t\t\tlet callStackElements = this.callStack.elements;\n\t\t\t\t\t\tfor (let i = callStackElements.length - 1; i >= 0; i--) {\n\t\t\t\t\t\t\tlet el = callStackElements[i];\n\t\t\t\t\t\t\tif (el.type == PushPopType.Function) {\n\t\t\t\t\t\t\t\tel.functionStartInOutputStream = -1;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse if (text.isNewline) {\n\t\t\t\tif (this.outputStreamEndsInNewline || !this.outputStreamContainsContent)\n\t\t\t\t\tincludeInOutput = false;\n\t\t\t}\n\t\t}\n\n\t\tif (includeInOutput) {\n\t\t\tif (obj === null) { return throwNullException('obj'); }\n\t\t\tthis._outputStream.push(obj);\n\t\t\tthis.OutputStreamDirty();\n\t\t}\n\t}\n\n\tpublic TrimNewlinesFromOutputStream(){\n\t\tlet removeWhitespaceFrom = -1;\n\n\t\tlet i = this._outputStream.length-1;\n\t\twhile (i >= 0) {\n\t\t\tlet obj = this._outputStream[i];\n\t\t\tlet cmd = asOrNull(obj, ControlCommand);\n\t\t\tlet txt = asOrNull(obj, StringValue);\n\n\t\t\tif (cmd != null || (txt != null && txt.isNonWhitespace)) {\n\t\t\t\tbreak;\n\t\t\t} else if (txt != null && txt.isNewline) {\n\t\t\t\tremoveWhitespaceFrom = i;\n\t\t\t}\n\t\t\ti--;\n\t\t}\n\n\t\t// Remove the whitespace\n\t\tif (removeWhitespaceFrom >= 0) {\n\t\t\ti=removeWhitespaceFrom;\n\t\t\twhile(i < this._outputStream.length) {\n\t\t\t\tlet text = asOrNull(this._outputStream[i], StringValue);\n\t\t\t\tif (text) {\n\t\t\t\t\tthis._outputStream.splice(i, 1);\n\t\t\t\t} else {\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.OutputStreamDirty();\n\t}\n\n\tpublic RemoveExistingGlue(){\n\t\tfor (let i = this._outputStream.length - 1; i >= 0; i--) {\n\t\t\tlet c = this._outputStream[i];\n\t\t\tif (c instanceof Glue) {\n\t\t\t\tthis._outputStream.splice(i, 1);\n\t\t\t} else if( c instanceof ControlCommand ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tthis.OutputStreamDirty();\n\t}\n\n\tget outputStreamEndsInNewline(){\n\t\tif (this._outputStream.length > 0) {\n\n\t\t\tfor (let i = this._outputStream.length - 1; i >= 0; i--) {\n\t\t\t\tlet obj = this._outputStream[i];\n\t\t\t\tif (obj instanceof ControlCommand)\n\t\t\t\t\tbreak;\n\t\t\t\tlet text = this._outputStream[i];\n\t\t\t\tif (text instanceof StringValue) {\n\t\t\t\t\tif (text.isNewline)\n\t\t\t\t\t\treturn true;\n\t\t\t\t\telse if (text.isNonWhitespace)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tget outputStreamContainsContent(){\n\t\tfor (let i = 0; i < this._outputStream.length; i++){\n\t\t\tif (this._outputStream[i] instanceof StringValue)\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tget inStringEvaluation(){\n\t\tfor (let i = this._outputStream.length - 1; i >= 0; i--) {\n\t\t\t// var cmd = this._outputStream[i] as ControlCommand;\n\t\t\tlet cmd = asOrNull(this._outputStream[i], ControlCommand);\n\t\t\tif (cmd instanceof ControlCommand && cmd.commandType == ControlCommand.CommandType.BeginString) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tpublic PushEvaluationStack(obj: InkObject | null){\n\t\t// var listValue = obj as ListValue;\n\t\tlet listValue = asOrNull(obj, ListValue);\n\t\tif (listValue) {\n\n\t\t\t// Update origin when list is has something to indicate the list origin\n\t\t\tlet rawList = listValue.value;\n\t\t\tif (rawList === null) { return throwNullException('rawList'); }\n\n\t\t\tif (rawList.originNames != null) {\n\t\t\t\tif (!rawList.origins) rawList.origins = [];\n\t\t\t\trawList.origins.length = 0;\n\n\t\t\t\tfor (let n of rawList.originNames) {\n\t\t\t\t\tif (this.story.listDefinitions === null) return throwNullException('StoryState.story.listDefinitions');\n\t\t\t\t\tlet def = this.story.listDefinitions.TryListGetDefinition(n, null);\n\t\t\t\t\tif (def.result === null) return throwNullException('StoryState def.result');\n\t\t\t\t\tif (rawList.origins.indexOf(def.result) < 0) rawList.origins.push(def.result);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (obj === null) { return throwNullException('obj'); }\n\t\tthis.evaluationStack.push(obj);\n\t}\n\n\tpublic PopEvaluationStack(): InkObject;\n\tpublic PopEvaluationStack(numberOfObjects: number): InkObject[];\n\tpublic PopEvaluationStack(numberOfObjects?: number){\n\t\tif (typeof numberOfObjects === 'undefined'){\n\t\t\tlet obj = this.evaluationStack.pop();\n\t\t\treturn nullIfUndefined(obj);\n\t\t} else {\n\t\t\tif(numberOfObjects > this.evaluationStack.length) {\n\t\t\t\tthrow new Error('trying to pop too many objects');\n\t\t\t}\n\n\t\t\tlet popped = this.evaluationStack.splice(this.evaluationStack.length - numberOfObjects, numberOfObjects);\n\t\t\treturn nullIfUndefined(popped);\n\t\t}\n\t}\n\n\tpublic PeekEvaluationStack(){\n\t\t return this.evaluationStack[this.evaluationStack.length - 1];\n\t}\n\n\tpublic ForceEnd(){\n\t\tthis.callStack.Reset();\n\n\t\tthis._currentChoices.length = 0;\n\n\t\tthis.currentPointer = Pointer.Null;\n\t\tthis.previousPointer = Pointer.Null;\n\n\t\tthis.didSafeExit = true;\n\t}\n\n\tpublic TrimWhitespaceFromFunctionEnd(){\n\t\tDebug.Assert (this.callStack.currentElement.type == PushPopType.Function);\n\t\tlet functionStartPoint = this.callStack.currentElement.functionStartInOutputStream;\n\n\t\tif (functionStartPoint == -1) {\n\t\t\tfunctionStartPoint = 0;\n\t\t}\n\n\t\tfor (let i = this._outputStream.length - 1; i >= functionStartPoint; i--) {\n\t\t\tlet obj = this._outputStream[i];\n\t\t\tlet txt = asOrNull(obj, StringValue);\n\t\t\tlet cmd = asOrNull(obj, ControlCommand);\n\n\t\t\tif (txt == null) continue;\n\t\t\tif (cmd) break;\n\n\t\t\tif (txt.isNewline || txt.isInlineWhitespace) {\n\t\t\t\tthis._outputStream.splice(i, 1);\n\t\t\t\tthis.OutputStreamDirty();\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic PopCallStack(popType: PushPopType | null = null) {\n\t\tif (this.callStack.currentElement.type == PushPopType.Function)\n\t\t\tthis.TrimWhitespaceFromFunctionEnd();\n\n\t\tthis.callStack.Pop(popType);\n\t}\n\n\tpublic SetChosenPath(path: Path, incrementingTurnIndex: boolean){\n\t\t// Changing direction, assume we need to clear current set of choices\n\t\tthis._currentChoices.length = 0;\n\n\t\tlet newPointer = this.story.PointerAtPath(path);\n\t\tif (!newPointer.isNull && newPointer.index == -1)\n\t\t\tnewPointer.index = 0;\n\n\t\tthis.currentPointer = newPointer;\n\n\t\tif (incrementingTurnIndex)\n\t\t\tthis._currentTurnIndex++;\n\t}\n\n\tpublic StartFunctionEvaluationFromGame(funcContainer: Container, args: any[]){\n\t\tthis.callStack.Push(PushPopType.FunctionEvaluationFromGame, this.evaluationStack.length);\n\t\tthis.callStack.currentElement.currentPointer = Pointer.StartOf(funcContainer);\n\n\t\tthis.PassArgumentsToEvaluationStack(args);\n\t}\n\n\tpublic PassArgumentsToEvaluationStack(args: any[]){\n\t\t// Pass arguments onto the evaluation stack\n\t\tif (args != null) {\n\t\t\tfor (let i = 0; i < args.length; i++) {\n\t\t\t\tif (!(typeof args[i] === 'number' || typeof args[i] === 'string')) {\n\t\t\t\t\tthrow new Error('ink arguments when calling EvaluateFunction / ChoosePathStringWithParameters  must be int, float or string');\n\t\t\t\t}\n\n\t\t\t\tthis.PushEvaluationStack(Value.Create(args[i]));\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic TryExitFunctionEvaluationFromGame(){\n\t\tif (this.callStack.currentElement.type == PushPopType.FunctionEvaluationFromGame) {\n\t\t\tthis.currentPointer = Pointer.Null;\n\t\t\tthis.didSafeExit = true;\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tpublic CompleteFunctionEvaluationFromGame(){\n\t\tif (this.callStack.currentElement.type != PushPopType.FunctionEvaluationFromGame) {\n\t\t\tthrow new StoryException('Expected external function evaluation to be complete. Stack trace: '+this.callStack.callStackTrace);\n\t\t}\n\n\t\tlet originalEvaluationStackHeight = this.callStack.currentElement.evaluationStackHeightWhenPushed;\n\n\t\tlet returnedObj: InkObject | null = null;\n\t\twhile (this.evaluationStack.length > originalEvaluationStackHeight) {\n\t\t\tlet poppedObj = this.PopEvaluationStack();\n\t\t\tif (returnedObj === null)\n\t\t\t\treturnedObj = poppedObj;\n\t\t}\n\n\t\tthis.PopCallStack(PushPopType.FunctionEvaluationFromGame);\n\n\t\tif (returnedObj) {\n\t\t\tif (returnedObj instanceof Void)\n\t\t\t\treturn null;\n\n\t\t\t// Some kind of value, if not void\n\t\t\t// var returnVal = returnedObj as Runtime.Value;\n\t\t\tlet returnVal = asOrThrows(returnedObj, Value);\n\n\t\t\t// DivertTargets get returned as the string of components\n\t\t\t// (rather than a Path, which isn't public)\n\t\t\tif (returnVal.valueType == ValueType.DivertTarget) {\n\t\t\t\treturn returnVal.valueObject.toString();\n\t\t\t}\n\n\t\t\t// Other types can just have their exact object type:\n\t\t\t// int, float, string. VariablePointers get returned as strings.\n\t\t\treturn returnVal.valueObject;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tpublic AddError(message: string, isWarning: boolean){\n\t\tif (!isWarning) {\n\t\t\tif (this._currentErrors == null) this._currentErrors = [];\n\t\t\tthis._currentErrors.push(message);\n\t\t} else {\n\t\t\tif (this._currentWarnings == null) this._currentWarnings = [];\n\t\t\tthis._currentWarnings.push(message);\n\t\t}\n\t}\n\n\tpublic OutputStreamDirty(){\n\t\tthis._outputStreamTextDirty = true;\n\t\tthis._outputStreamTagsDirty = true;\n\t}\n\n\tprivate _outputStream: InkObject[];\n\tprivate _outputStreamTextDirty = true;\n\tprivate _outputStreamTagsDirty = true;\n\tprivate _currentChoices: Choice[];\n}\n","// This is simple replacement of the Stopwatch class from the .NET Framework.\n// The original class can count time with much more accuracy than the Javascript version.\n// It might be worth considering using `window.performance` in the browser\n// or `process.hrtime()` in node.\nexport class Stopwatch {\n\n\tprivate startTime: number | undefined;\n\n\tconstructor(){\n\t\tthis.startTime = undefined;\n\t}\n\n\tget ElapsedMilliseconds(): number{\n\t\tif (typeof this.startTime === 'undefined'){\n\t\t\treturn 0;\n\t\t}\n\t\treturn (new Date().getTime()) - this.startTime;\n\t}\n\n\tpublic Start(){\n\t\tthis.startTime = new Date().getTime();\n\t}\n\tpublic Stop(){\n\t\tthis.startTime = undefined;\n\t}\n}\n"],"names":["Path","Component","Debug","_components","_componentsString","_isRelative","arguments","componentsString","head","tail","push","this","concat","Array","relative","index","pathToAppend","p","upwardMoves","i","length","isParent","otherPath","isRelative","l","Equals","c","apply","slice","self","lastComponentIdx","isIndex","join","value","substring","componentStrings","split","str","test","parseInt","path","asOrNull","obj","type","unsafeTypeAssertion","asOrThrows","Error","asNumberOrThrows","asINamedContentOrNull","hasValidName","name","nullIfUndefined","indexOrName","toString","otherComp","parentId","Assert","condition","message","console","warn","trace","variable","NullException","throwNullException","InkObject","root","rootContentContainer","targetContent","ContentAtPath","dm","debugMetadata","startLineNumber","nearestContainer","Container","parent","GetComponent","contentContainer","globalPath","ownPath","minPathLength","Math","min","lastSharedPathCompIndex","ownComp","numUpwardsMoves","componentCount","newPathComps","up","ToParent","down","globalPathStr","relativePathStr","PathByAppendingPath","ConvertPathToRelative","prop","_debugMetadata","_path","comps","child","container","namedChild","unshift","content","indexOf","ancestor","StringBuilder","string","Append","format","args","replace","match","num","InkListItem","originName","itemName","nameParts","fullName","otherItem","JSON","stringify","key","parse","isLikeInkListItem","Null","inkListItem","item","_typeof","hasOwnProperty","InkList","otherList","_originNames","singleOriginListName","originStory","SetInitialOriginName","def","listDefinitions","TryListGetDefinition","exists","origins","result","singleElement","Add","Key","Value","Map","itemOrItemName","AddItem","origin","intVal","TryGetValueForItem","foundListDef","ContainsItemWithName","itemVal","ValueForItem","fromSerializedKey","has","serialized","serializedKey","set","initialOriginName","initialOriginNames","union","intersection","listToRemove","Count","minItem","maxItem","minBound","maxBound","ordered","orderedItems","minValue","maxValue","Number","MAX_SAFE_INTEGER","isInteger","subList","SetInitialOriginNames","originNames","otherInkList","sb","NaN","size","maxOriginName","every","max","isNull","list","items","ContainsKey","sort","x","y","localeCompare","StoryException","useEndLineNumber","tryGetValueFromMap","map","val","get","ValueType","AbstractValue","Create","targetType","valueObject","valueType","StringValue","String","IntValue","isNaN","DivertTargetValue","ListValue","FloatValue","newType","Float","BadCastException","Int","_isNewline","_this2","_isInlineWhitespace","parsedInt","defaultValue","tryParseInt","parsedFloat","parseFloat","tryParseFloat","isNewline","isInlineWhitespace","targetPath","DivertTarget","VariablePointerValue","variableName","contextIndex","_contextIndex","VariablePointer","listOrSingleItem","singleValue","List","oldValue","newValue","oldList","newList","CountFlags","SearchResult","searchResult","approximate","contentObjOrList","contentList","AddContent","contentObj","_content","TryAddNamedContent","namedContentObj","AddToNamedContentOnly","AssertType","namedContent","partialPathStart","partialPathLength","currentContainer","currentObj","comp","foundObj","ContentWithPathComponent","otherContainer","component","foundContent","BuildStringOfHierarchy","indentation","pointedObj","appendIndentation","AppendFormat","AppendLine","onlyNamed","namedOnlyContentDict","inkObject","named","existingNamedOnly","namedOnlyContent","flags","visitsShouldBeCounted","Visits","turnIndexShouldBeCounted","Turns","countingAtStartOnly","CountStartOnly","flag","_pathToFirstLeafContent","internalPathToFirstLeafContent","components","ControlCommand","CommandType","PushPopType","Glue","commandType","NotSet","_commandType","EvalStart","EvalOutput","EvalEnd","Duplicate","PopEvaluatedValue","PopFunction","PopTunnel","BeginString","EndString","NoOp","ChoiceCount","TurnsSince","ReadCount","Random","SeedRandom","VisitIndex","SequenceShuffleIndex","StartThread","Done","End","ListFromInt","ListRange","ListRandom","Pointer","PathByAppendingComponent","Divert","stackPushType","pushesToStack","otherDivert","hasVariableTarget","variableDivertName","targetStr","isConditional","Function","targetPathString","_targetPath","targetObj","targetPointer","Resolve","_targetPointer","ResolvePath","lastComponent","StartOf","copy","CompactPathString","ChoicePoint","onceOnly","pathOnChoice","_pathOnChoice","choiceTargetObj","choiceTarget","hasCondition","hasStartContent","hasChoiceOnlyContent","isInvisibleDefault","VariableReference","pathStringForCount","pathForCount","VariableAssignment","isNewDeclaration","isGlobal","Void","NativeFunctionCall","GenerateNativeFunctionsIfNecessary","numberOfParameters","_isPrototype","parameters","_prototype","Call","hasList","CallBinaryListOperation","coercedParams","CoerceValuesToSingleType","coercedType","CallType","parametersOfSingleType","param1","valType","val1","paramCount","_operationFuncs","opForTypeObj","val2","opForType","resultVal","CallListIncrementOperation","v1","v2","op","isTruthy","listIntParams","listVal","resultInkList","listItemKey","listItemValue","listItem","intOp","targetInt","itemOrigin","incrementedItem","TryGetItemWithValue","parametersIn","specialCaseList","parametersOut","originOfMaxItem","castedValue","Cast","_name","_nativeFunctions","_numberOfParameters","functionName","t","AddIntBinaryOp","Subtract","Multiply","Divide","round","Mod","AddIntUnaryOp","Negate","Equal","Greater","Less","GreaterThanOrEquals","LessThanOrEquals","NotEquals","Not","And","Or","Max","Min","Pow","pow","Floor","Identity","Ceiling","AddFloatBinaryOp","AddFloatUnaryOp","floor","ceil","AddStringBinaryOp","Has","includes","Hasnt","AddListBinaryOp","Union","Without","Contains","Intersect","GreaterThan","LessThan","AddListUnaryOp","Invert","inverse","All","all","ListMin","MinAsList","ListMax","MaxAsList","ValueOfList","AddOpToNativeFunc","d1","d2","nativeFunc","AddOpFuncForType","Tag","tagText","text","Choice","ListDefinition","_items","_itemNameToValues","ListDefinitionsOrigin","lists","_lists","_allUnambiguousListValueCache","listValue","definition","listOfLists","JsonSerialisation","serialisables","jArray","s","RuntimeObjectToJToken","skipLast","count","jTok","runtimeObj","JTokenToRuntimeObject","dictionary","jsonObj","jObject","dict","jObj","token","firstChar","_controlCommandNames","CallExistsWithName","CallWithName","isArray","propValue","varPtr","isDivert","divPushType","external","Tunnel","divert","isExternal","target","externalArgs","choice","pathStringOnChoice","readCountVarRef","isVarAss","isGlobalVar","varName","isNewDecl","varAss","undefined","listContent","rawList","namesAsObjs","nameToVal","JObjectToChoice","JArrayToContainer","ContainerToJArray","divTypeKey","choicePoint","floatVal","strVal","InkListToJObject","divTargetVal","divTargetJsonObj","varPtrVal","varPtrJsonObj","controlCmd","varRef","readCountPath","tag","ChoiceToJObject","ListToJArray","countFlags","terminatingObj","DictionaryRuntimeObjsToJObject","subContainerJArray","attrJObj","Object","keys","JArrayToRuntimeObjList","namedContentItem","namedSubContainer","sourcePath","originalThreadIndex","listDefJson","defsObj","allDefs","nameValueKey","nameValue","TOTAL_VALUES","CallStack","Story","storyContext","_startOfRoot","Reset","toCopy","_threads","otherThread","Copy","Thread","callstack","Element","jThreads","jThreadTok","thread","_threadCounter","jsonToken","newThread","currentThread","threadIndex","forkedThread","canPopThread","splice","externalEvaluationStackHeight","outputStreamLengthWithPushed","element","currentElement","currentPointer","evaluationStackHeightWhenPushed","functionStartInOutputStream","callStack","canPop","CanPop","pop","currentElementIndex","varValue","temporaryVariables","declareNew","contextElement","RetainListOriginsForAssignment","filter","elements","cs","elementIsEvaluateFromGame","FunctionEvaluationFromGame","isCurrent","pointer","inExpressionEvaluation","jThreadObj","jThreadCallstack","jElementObj","pushPopType","currentContainerPathStr","currentContainerPathStrToken","threadPointerResult","Warning","el","jObjTemps","JObjectToDictionaryRuntimeObjs","prevContentObjPath","prevPath","previousPointer","PointerAtPath","e","threadJObj","resolvedPointer","OutputStateChange","VariablesState","listDefsOrigin","Set","_globalVariables","_callStack","_listDefsOrigin","Proxy","$","variableChangedEventCallbacks","callback","varContents","_defaultGlobalVariables","SetGlobal","variableChangedEvent","batchObservingVariableChanges","_batchObservingVariableChanges","_changedVariables","GetRawVariableWithName","varPointer","ValueAtVariablePointer","variableValue","FindSingleItemListWithName","GetTemporaryVariableWithName","GetVariableWithName","setGlobal","ResolveVariablePointer","existingPointer","SetTemporaryVariable","add","GetContextIndexOfVariableNamed","doubleRedirectionPointer","currentValue","PRNG","seed","next","StoryState","story","_outputStream","OutputStreamDirty","_evaluationStack","_variablesState","_visitCounts","_turnIndices","_currentTurnIndex","timeSeed","Date","getTime","storySeed","previousRandom","_currentChoices","GoToStart","indented","ToJson","json","pathString","visitCountOut","visitCounts","currentWhitespaceStart","startOfLine","charAt","mainContentContainer","outputStream","hasError","_currentErrors","currentErrors","hasWarning","_currentWarnings","currentWarnings","variablesState","CopyFrom","evaluationStack","divertedPointer","turnIndices","currentTurnIndex","didSafeExit","objs","listText","TrySplittingHeadTailWhitespace","textObj","PushToOutputStreamIndividual","single","headFirstNewlineIdx","headLastNewlineIdx","tailLastNewlineIdx","tailFirstNewlineIdx","listTexts","innerStrStart","innerStrEnd","leadingSpaces","innerStrText","numSpaces","trailingSpaces","glue","includeInOutput","TrimNewlinesFromOutputStream","functionTrimIndex","currEl","glueTrimIndex","o","isNonWhitespace","RemoveExistingGlue","callStackElements","outputStreamEndsInNewline","outputStreamContainsContent","removeWhitespaceFrom","cmd","txt","n","numberOfObjects","functionStartPoint","popType","TrimWhitespaceFromFunctionEnd","Pop","incrementingTurnIndex","newPointer","funcContainer","Push","PassArgumentsToEvaluationStack","PushEvaluationStack","callStackTrace","originalEvaluationStackHeight","returnedObj","poppedObj","PopEvaluationStack","PopCallStack","returnVal","isWarning","_outputStreamTextDirty","_outputStreamTagsDirty","depth","canContinue","textContent","_currentText","CleanOutputWhitespace","_currentTags","choiceThreads","threadAtGeneration","ThreadWithIndex","GetJsonToken","IntDictionaryToJObject","kInkSaveStateVersion","inkVersionCurrent","jSaveVersion","kMinCompatibleLoadVersion","SetJsonToken","currentDivertTargetPath","divertPath","JObjectToIntDictionary","jChoiceThreads","foundActiveThread","jSavedChoiceThread","Stopwatch","startTime","nVal","isFinite","_mainContentContainer","jsonString","_this","_listDefinitions","_externals","rootObject","versionObj","formatFromFile","inkVersionMinimumCompatible","listDefsObj","rootToken","JTokenToListDefinitions","ResetState","rootContainerJsonList","ListDefinitionsToJToken","IfAsyncWeCant","_state","ObserveVariableChange","VariableStateDidChangeEvent","bind","ResetGlobals","ResetErrors","ForceEnd","originalPointer","state","ChoosePath","ContinueInternal","SnapshotDefaultGlobals","ContinueAsync","currentText","millisecsLimitAsync","_hasValidatedExternals","ValidateExternalBindings","_profiler","PreContinue","isAsyncTimeLimited","_recursiveContinueCount","_asyncContinueActive","ResetOutput","durationStopwatch","Start","ContinueSingleStep","AddError","ElapsedMilliseconds","Stop","_stateAtLastNewline","RestoreStateSnapshot","generatedChoices","_temporaryEvaluationContainer","PostContinue","PreStep","Step","PostStep","TryFollowDefaultInvisibleChoice","PreSnapshot","inStringEvaluation","currentTags","change","CalculateNewlineOutputStateChange","ExtendedBeyondNewline","NewlineRemoved","StateSnapshot","PostSnapshot","prevText","currText","prevTagCount","currTagCount","newlineStillExists","NoChange","Continue","namedContainer","pathLengthToUse","shouldAddToStream","containerToEnter","VisitContainer","currentContentObj","isLogicOrFlowControl","PerformLogicAndFlowControl","ProcessChoice","contextIdx","ContextForVariableNamed","PushToOutputStream","NextContent","PushThread","atStart","IncrementVisitCountForContainer","RecordTurnIndexVisitToContainer","_prevContainers","prevAncestor","currentChildOfContainer","currentContainerAncestor","enteringAtStart","showChoice","conditionValue","IsTruthy","startText","choiceOnlyText","VisitCountForContainer","ForkThread","divTarget","currentDivert","intContent","errorMessage","CallExternalFunction","sourceName","evalCommand","output","PeekEvaluationStack","overrideTunnelReturnTarget","popped","TryExitFunctionEvaluationFromGame","names","expected","errorMsg","contentStackForString","outputCountConsumed","command","PopFromOutputStream","reverse","choiceCount","extraNote","eitherCount","divertTarget","correctObj","TurnsSinceForContainer","maxInt","minInt","randomRange","resultSeed","nextRandom","chosenValue","shuffleIndex","NextSequenceShuffleIndex","PopThread","listNameVal","generatedListValue","foundItem","targetList","ListWithSubRange","listItemIndex","listEnumerator","entries","randomItem","assignedVal","Assign","foundValue","containerForCount","defaultVal","TryGetDefaultVariableValue","func","funcParams","resetCallstack","ResetCallstack","funcDetail","activityStr","SetChosenPath","VisitChangedContainersDueToDivert","choiceIdx","choices","currentChoices","choiceToChoose","KnotContainerWithName","returnTextOutput","trim","outputStreamBefore","StartFunctionEvaluationFromGame","stringOutput","textOutput","CompleteFunctionEvaluationFromGame","returned","exprContainer","startCallStackHeight","evalStackHeight","funcName","numberOfArguments","fallbackFunctionContainer","allowExternalFunctionFallbacks","valueObj","funcResult","returnObj","BindExternalFunctionGeneral","coercedArgs","TryCoerce","missingExternals","from","innerContent","observer","_variableObservers","GlobalVariableExistsWithName","variableNames","observers","ObserveVariable","specificVariableName","newValueObj","TagsAtStartOfFlowContainerWithPathString","flowContainer","firstContent","tags","IncrementContentPointer","didPop","successfulIncrement","nextAncestor","indexInAncestor","allChoices","invisibleChoices","containerPathStr","numElementsIntVal","seqContainer","numElements","seqCount","loopIndex","iterationIndex","seqPathStr","sequenceHash","charCodeAt","randomSeed","random","unpickedIndices","chosen","chosenIndex","currentDebugMetadata","errorTypeStr","lineNum","endLineNumber","fileName"],"mappings":"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"}